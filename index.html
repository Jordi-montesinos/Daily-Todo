<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Weekly Task Organizer</title>

  <!-- React + Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    body { margin: 0; }
    table td, table th { vertical-align: top; }
    input[type=number]::-webkit-outer-spin-button,
    input[type=number]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    input[type=number] { -moz-appearance: textfield; }
  </style>
</head>

<body class="bg-gray-100 min-h-screen">
  <div id="root"></div>

<script type="text/babel">
const { useState, useEffect, useRef, useMemo } = React;

/* ---------- ISO week helpers ---------- */
function getISOWeekAndYear(date) {
  const tmp = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
  tmp.setUTCDate(tmp.getUTCDate() + 4 - (tmp.getUTCDay() || 7));
  const yearStart = new Date(Date.UTC(tmp.getUTCFullYear(), 0, 1));
  const weekNo = Math.ceil((((tmp - yearStart) / 86400000) + 1) / 7);
  return [weekNo, tmp.getUTCFullYear()];
}
function getDateOfISOWeek(week, year) {
  const jan4 = new Date(Date.UTC(year, 0, 4));
  const jan4Day = jan4.getUTCDay() || 7;
  const monday = new Date(jan4);
  monday.setUTCDate(jan4.getUTCDate() - (jan4Day - 1) + (week - 1) * 7);
  return new Date(monday.getUTCFullYear(), monday.getUTCMonth(), monday.getUTCDate());
}
function formatDayShort(d) {
  const dd = String(d.getDate()).padStart(2,'0');
  const monthNames = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
  return dd + '/' + monthNames[d.getMonth()];
}
function pad2(n){ return String(n).padStart(2,'0'); }

function weekKey(w){
  const yr = Number(w.year) || 0;
  const wn = Number(w.weekNumber) || 0;
  return `${yr}-W${pad2(wn)}`;
}

/* ---------- category parsing ---------- */
function extractCategory(text){
  // format: "xxx xxx - yyy"
  const m = String(text || "").match(/^(.+?)\s-\s.+$/);
  return m ? m[1].trim() : "(uncategorized)";
}

/* ---------- line state (subtask) helpers ---------- */
function getLinesFromText(text){
  return String(text || "")
    .split("\n")
    .map(s => s.replace(/\r/g, "")); // keep empty lines as empty string (so layout is identical)
}
function normalizeLineStates(cell){
  // Store completion state per line text; keep entry behavior identical (textarea stays the source of truth).
  const lines = getLinesFromText(cell.text);
  const prev = Array.isArray(cell.lineStates) ? cell.lineStates : [];
  const next = lines.map((line) => {
    // preserve by exact text match (best effort)
    const found = prev.find(p => p.text === line);
    return { text: line, done: found ? !!found.done : false };
  });
  return { ...cell, lineStates: next };
}
function toggleLineDone(cell, lineIndex){
  const ls = Array.isArray(cell.lineStates) ? [...cell.lineStates] : [];
  if(!ls[lineIndex]) return cell;
  ls[lineIndex] = { ...ls[lineIndex], done: !ls[lineIndex].done };
  return { ...cell, lineStates: ls };
}

/* ---------- tasks/week defaults ---------- */
function makeEmptyTasks() {
  return Array(16).fill(null).map((_, i) => ({
    delegatedTasks:   { text: "", status: 0, ranking: i+1, lineStates: [] },
    weeklyObjectives: { text: "", status: 0, ranking: i+1, lineStates: [] },
    monday:           { text: "", status: 0, ranking: i+1, lineStates: [] },
    tuesday:          { text: "", status: 0, ranking: i+1, lineStates: [] },
    wednesday:        { text: "", status: 0, ranking: i+1, lineStates: [] },
    thursday:         { text: "", status: 0, ranking: i+1, lineStates: [] },
    friday:           { text: "", status: 0, ranking: i+1, lineStates: [] }
  }));
}

/* compute current week/year for defaults */
const [currentWeek, currentYear] = getISOWeekAndYear(new Date());

function WeeklyTaskOrganizer() {
  /* ---- init + migration ---- */
  const initial = () => {
    const saved = localStorage.getItem('weekly-task-organizer');
    if (saved) {
      try {
        let parsed = JSON.parse(saved);
        parsed.forEach(week => {
          week.tasks.forEach(row => {
            Object.keys(row).forEach(col => {
              const cell = row[col];
              if (!cell) return;

              // migrate completed -> status
              if (cell.status === undefined) {
                cell.status = cell.completed ? 2 : 0;
                delete cell.completed;
              }

              // ensure lineStates exists
              if (!Array.isArray(cell.lineStates)) cell.lineStates = [];
              // normalize to current text (no duplication; preserves done when possible)
              row[col] = normalizeLineStates(cell);
            });
          });
        });
        return parsed;
      } catch {}
    }
    return [{
      id: Date.now(),
      weekNumber: currentWeek,
      year: currentYear,
      tasks: makeEmptyTasks()
    }];
  };

  const [weeks, setWeeks] = useState(initial);
  const [activeTab, setActiveTab] = useState('organizer'); // organizer | summary | analytics

  const [draggedItem, setDraggedItem] = useState(null);
  const [dragOverRow, setDragOverRow] = useState(null);

  const inputRefs = useRef({});
  const fileInputRef = useRef(null);
  const [copiedKeys, setCopiedKeys] = useState(()=> new Set());

  const columns = ["delegatedTasks","weeklyObjectives","monday","tuesday","wednesday","thursday","friday"];

  /* ---- autosave download (only after real edits) ---- */
  const lastUserEditAtRef = useRef(0);
  const lastAutoDownloadAtRef = useRef(0);

  function markUserEdit(){
    lastUserEditAtRef.current = Date.now();
  }

  /* colors */
  function getWeeklyObjectivesColor(i){
    if(i<=3) return { bg:"#dc2626", text:"white" };
    if(i<=7) return { bg:"#f97316", text:"white" };
    if(i<=11) return { bg:"#facc15", text:"black" };
    return { bg:"#fde68a", text:"black" };
  }
  function getDayColumnColor(i){
    if(i===0) return { bg:"#dc2626", text:"white" };
    if(i<=3) return { bg:"#fcd34d", text:"black" };
    if(i>=14) return { bg:"#eff6ff", text:"black" };
    return { bg:"#ffffff", text:"black" };
  }
  function getCellStyle(col, rowIndex, text){
    const base =
      col === 'weeklyObjectives' ? getWeeklyObjectivesColor(rowIndex) :
      col === 'delegatedTasks' ? { bg:"#ffffff", text:"black" } :
      getDayColumnColor(rowIndex);

    if(!text || text.trim()===""){
      return {
        bg: base.bg.includes("#") ? base.bg + "33" : "#f3f4f6",
        text: "#9ca3af",
        ghost: true
      };
    }
    return { ...base, ghost: false };
  }

  function isBlankCell(cell){
    return !cell || !cell.text || cell.text.trim() === "";
  }

  /* ---- sorting + categories ---- */
  function getCategoryRange(col, rowIndex){
    if(col === 'weeklyObjectives'){
      if(rowIndex <= 3) return [0,3];
      if(rowIndex <= 7) return [4,7];
      if(rowIndex <= 11) return [8,11];
      return [12,15];
    }
    if(col === 'delegatedTasks') return [0,15];
    if(rowIndex === 0) return [0,0];
    if(rowIndex <= 3) return [1,3];
    if(rowIndex <= 13) return [4,13];
    return [14,15];
  }

  function sortColumnByCategory(tasks, col) {
    const newTasks = [...tasks];
    const ranges = [
      getCategoryRange(col,0),
      getCategoryRange(col,4),
      getCategoryRange(col,8),
      getCategoryRange(col,12)
    ];

    ranges.forEach(([start,end]) => {
      const seg = [];
      for (let i = start; i <= end; i++) seg.push({ task: newTasks[i][col], rowIndex: i });

      const filled   = seg.filter(s => s.task.text.trim() !== "" && s.task.status !== 2);
      const complete = seg.filter(s => s.task.text.trim() !== "" && s.task.status === 2);
      const blanks   = seg.filter(s => s.task.text.trim() === "");

      const merged = [...filled, ...complete, ...blanks];

      merged.forEach((it, idx) => {
        const normalized = normalizeLineStates({ ...it.task, ranking: idx + 1 });
        newTasks[start + idx] = { ...newTasks[start + idx], [col]: normalized };
      });
    });

    return newTasks;
  }

  /* ---- updater: IMPORTANT (keep typing stable) ---- */
  function updateTask(weekId, rowIndex, col, field, value) {
    markUserEdit();
    setWeeks(prev => prev.map(w => {
      if (w.id !== weekId) return w;
      let newTasks = [...w.tasks];

      const curCell = newTasks[rowIndex][col];
      let nextCell = { ...curCell, [field]: value };

      // Keep lineStates synced to text *without changing textarea behavior*:
      if(field === "text"){
        nextCell = normalizeLineStates(nextCell);
      }

      newTasks[rowIndex] = { ...newTasks[rowIndex], [col]: nextCell };

      // only auto-sort if NOT typing text (prevents cursor jumping)
      if (field !== "text") {
        newTasks = sortColumnByCategory(newTasks, col);
      }

      return { ...w, tasks: newTasks };
    }));
  }

  function toggleLine(weekId, rowIndex, col, lineIndex){
    markUserEdit();
    setWeeks(prev => prev.map(w => {
      if(w.id !== weekId) return w;
      const tasks = [...w.tasks];
      const cell = tasks[rowIndex][col];
      tasks[rowIndex] = { ...tasks[rowIndex], [col]: toggleLineDone(cell, lineIndex) };
      return { ...w, tasks };
    }));
  }

  /* Auto-resize all textareas on load/refresh */
  useEffect(() => {
    Object.values(inputRefs.current).forEach(el => {
      if (el) {
        el.style.height = 'auto';
        el.style.height = el.scrollHeight + 'px';
      }
    });
  }, [weeks]);

  // reset highlight if drag ends outside a cell
  useEffect(() => {
    const onDropAnywhere = () => setDragOverRow(null);
    const onDragEnd = () => setDragOverRow(null);
    window.addEventListener('drop', onDropAnywhere);
    window.addEventListener('dragend', onDragEnd);
    return () => {
      window.removeEventListener('drop', onDropAnywhere);
      window.removeEventListener('dragend', onDragEnd);
    };
  }, []);

  /* drag/drop (cross-columns + copy with CTRL) */
  function handleDrop(e, weekId, targetRow, targetCol) {
    e.preventDefault();
    if (!draggedItem || draggedItem.weekId !== weekId) {
      setDraggedItem(null);
      return;
    }

    const isCopy = e.ctrlKey;

    markUserEdit();
    setWeeks(prev => prev.map(w => {
      if (w.id !== weekId) return w;
      let tasks = [...w.tasks];

      const srcCol = draggedItem.col;
      const srcRow = draggedItem.rowIndex;
      const dragged = tasks[srcRow][srcCol];

      if (isBlankCell(dragged)) return w;

      const target = tasks[targetRow][targetCol];

      // clear source if move
      if (!isCopy) {
        tasks[srcRow] = {
          ...tasks[srcRow],
          [srcCol]: { text:"", status:0, ranking: srcRow+1, lineStates: [] }
        };
      }

      if (isBlankCell(target)) {
        tasks[targetRow] = {
          ...tasks[targetRow],
          [targetCol]: { ...dragged, ranking: targetRow+1 }
        };
      } else {
        // push down within target column
        for (let i = tasks.length-1; i > targetRow; i--) {
          tasks[i] = {
            ...tasks[i],
            [targetCol]: { ...tasks[i-1][targetCol], ranking:i+1 }
          };
        }
        tasks[targetRow] = {
          ...tasks[targetRow],
          [targetCol]: { ...dragged, ranking: targetRow+1 }
        };
      }

      tasks = sortColumnByCategory(tasks, targetCol);
      if (!isCopy) tasks = sortColumnByCategory(tasks, srcCol);

      return { ...w, tasks };
    }));

    setDraggedItem(null);
  }

  /* keyboard nav + alt+enter */
  function focusCell(weekId, row, col){
    if(row < 0 || col < 0 || col >= columns.length || row >= 16) return;
    const key = `${weekId}-${row}-${col}`;
    const el = inputRefs.current[key];
    if(el) el.focus();
  }

  function handleKeyDown(e, weekId, row, colIndex){
    // Enter = move down (and reorg first)
    if(e.key === 'Enter' && !e.shiftKey && !e.altKey){
      e.preventDefault();
      const col = columns[colIndex];

      // force reorg before moving focus
      setWeeks(prev => prev.map(w => {
        if(w.id !== weekId) return w;
        const newTasks = sortColumnByCategory([...w.tasks], col);
        return { ...w, tasks: newTasks };
      }));

      focusCell(weekId, row+1, colIndex);
      return;
    }

    // Alt+Enter = newline (keep EXACT original behavior)
    if(e.key === 'Enter' && e.altKey){
      e.preventDefault();
      const el = e.target;
      const start = el.selectionStart;
      const end = el.selectionEnd;
      el.value = el.value.slice(0, start) + '\n' + el.value.slice(end);
      el.selectionStart = el.selectionEnd = start + 1;

      // push value into state (so line buttons appear) WITHOUT sorting
      const col = columns[colIndex];
      updateTask(weekId, row, col, 'text', el.value);
      return;
    }

    if(e.key === 'Enter' && e.shiftKey){
      e.preventDefault(); focusCell(weekId, row-1, colIndex); return;
    }
    if(e.key === 'Tab' && !e.shiftKey){
      e.preventDefault(); focusCell(weekId, row, colIndex+1); return;
    }
    if(e.key === 'Tab' && e.shiftKey){
      e.preventDefault(); focusCell(weekId, row, colIndex-1); return;
    }
  }

  /* add new week */
  function addNewWeek(){
    markUserEdit();
    const prev = weeks[0];
    const nowYear = new Date().getFullYear();
    const nextNum = prev && typeof prev.weekNumber === 'number' ? prev.weekNumber + 1 : currentWeek;

    const newWeek = { id: Date.now(), weekNumber: nextNum, year: nowYear, tasks: makeEmptyTasks() };
    if(prev){
      const openDel = prev.tasks.filter(t => t.delegatedTasks.text.trim() && t.delegatedTasks.status !== 2);
      const openObj = prev.tasks.filter(t => t.weeklyObjectives.text.trim() && t.weeklyObjectives.status !== 2);

      openDel.forEach((t, idx) => { if(idx < 16) newWeek.tasks[idx].delegatedTasks = normalizeLineStates({ ...t.delegatedTasks, status:0 }); });
      openObj.forEach((t, idx) => { if(idx < 16) newWeek.tasks[idx].weeklyObjectives = normalizeLineStates({ ...t.weeklyObjectives, status:0 }); });
    }
    setWeeks([newWeek, ...weeks]);
  }

  /* save/load */
  function saveToFile(){
    const blob = new Blob([JSON.stringify(weeks, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    const today = new Date().toISOString().split('T')[0];
    a.download = `weekly-organizer-${today}.json`;
    a.click();
    URL.revokeObjectURL(a.href);

    lastAutoDownloadAtRef.current = Date.now();
  }

  function loadFromFile(e){
    const f = e.target.files?.[0]; if(!f) return;
    const r = new FileReader();
    r.onload = ev => {
      try {
        const parsed = JSON.parse(ev.target.result);
        // normalize lineStates
        parsed.forEach(week => {
          week.tasks.forEach(row => {
            Object.keys(row).forEach(col => {
              if(!row[col]) return;
              if (row[col].status === undefined) {
                row[col].status = row[col].completed ? 2 : 0;
                delete row[col].completed;
              }
              row[col] = normalizeLineStates({ ...row[col], lineStates: row[col].lineStates || [] });
            });
          });
        });
        setWeeks(parsed);
      } catch {
        alert('Invalid file');
      }
    };
    r.readAsText(f);
  }

  /* localStorage autosave */
  useEffect(()=> {
    try { localStorage.setItem('weekly-task-organizer', JSON.stringify(weeks)); } catch {}
  }, [weeks]);

  /* auto-download 2 minutes after last REAL edit */
  useEffect(() => {
    const check = () => {
      const lastEdit = lastUserEditAtRef.current;
      if(!lastEdit) return;
      const already = lastAutoDownloadAtRef.current;
      // only run once per edit "epoch"
      if(already >= lastEdit) return;
      const now = Date.now();
      if(now - lastEdit >= 2 * 60 * 1000){
        saveToFile();
      }
    };

    const id = setInterval(check, 5000);
    return () => clearInterval(id);
  }, []);

  /* week number edit */
  function updateWeekNumber(weekId, newNumber){
    markUserEdit();
    setWeeks(prev => prev.map(w => w.id === weekId ? { ...w, weekNumber: newNumber } : w));
  }

  /* today detection */
  const today = new Date();
  const todayKey = `${today.getFullYear()}-${today.getMonth()}-${today.getDate()}`;

  /* summary */
  const [summaryFilter, setSummaryFilter] = useState('All');
  const summaryRows = useMemo(() => {
    const rows = [];
    const mapColName = {
      delegatedTasks: 'Delegated',
      weeklyObjectives: 'Objectives',
      monday: 'Monday',
      tuesday: 'Tuesday',
      wednesday: 'Wednesday',
      thursday: 'Thursday',
      friday: 'Friday'
    };

    weeks.slice().reverse().forEach(w => {
      columns.forEach(col => {
        w.tasks.forEach((t, idx) => {
          const cell = t[col];
          if (cell.text.trim() && cell.status !== 2) {
            rows.push({
              key: `${w.id}-${col}-${idx}`,
              weekId: w.id,
              weekNumber: w.weekNumber,
              year: w.year,
              col,
              colLabel: mapColName[col],
              text: cell.text
            });
          }
        });
      });
    });

    return rows.filter(r => {
      if(summaryFilter === 'All') return true;
      if(summaryFilter === 'Delegated') return r.col === 'delegatedTasks';
      if(summaryFilter === 'Objectives') return r.col === 'weeklyObjectives';
      if(summaryFilter === 'Days') return ['monday','tuesday','wednesday','thursday','friday'].includes(r.col);
      return true;
    });
  }, [weeks, summaryFilter]);

  function addAllToNextWeekFromSummary(){
    if(summaryRows.length === 0) return;
    markUserEdit();

    const latest = weeks[0];
    const nowYear = new Date().getFullYear();
    const nextNum = latest && typeof latest.weekNumber === 'number' ? latest.weekNumber + 1 : currentWeek;

    let nextWeek = weeks.find(w => w.weekNumber === nextNum && w.year === nowYear);
    if(!nextWeek){
      nextWeek = { id: Date.now(), weekNumber: nextNum, year: nowYear, tasks: makeEmptyTasks() };
      setWeeks(prev => [nextWeek, ...prev]);
      setTimeout(()=> doCopyTo(nextWeek.id), 0);
    } else {
      doCopyTo(nextWeek.id);
    }
  }

  function doCopyTo(nextWeekId){
    setWeeks(prev => prev.map(w => {
      if(w.id !== nextWeekId) return w;
      const tasks = [...w.tasks];
      let writeIndex = 15;
      summaryRows.forEach(row => {
        if(writeIndex < 0) return;
        tasks[writeIndex].weeklyObjectives = normalizeLineStates({ text: row.text, status: 0, ranking: writeIndex+1, lineStates: [] });
        writeIndex--;
      });
      return { ...w, tasks };
    }));

    setCopiedKeys(prev => {
      const next = new Set(prev);
      summaryRows.forEach(r => next.add(r.key));
      return next;
    });
  }

  /* ---------- ANALYTICS ---------- */
  const [analyticsMode, setAnalyticsMode] = useState("all"); // all | done | open
  const analyticsWeeks = useMemo(() => {
    const list = weeks.slice().sort((a,b)=>{
      const ka = weekKey(a), kb = weekKey(b);
      return ka.localeCompare(kb);
    });
    return list.map(w => ({
      key: weekKey(w),
      year: w.year,
      weekNumber: w.weekNumber,
      week: w
    }));
  }, [weeks]);

  const [rangeStart, setRangeStart] = useState("");
  const [rangeEnd, setRangeEnd] = useState("");

  useEffect(() => {
    if(analyticsWeeks.length === 0) return;
    if(!rangeStart) setRangeStart(analyticsWeeks[0].key);
    if(!rangeEnd) setRangeEnd(analyticsWeeks[analyticsWeeks.length-1].key);
  }, [analyticsWeeks]);

  function inMode(cell){
    if(!cell || !cell.text || !cell.text.trim()) return false;
    if(analyticsMode === "all") return true;
    if(analyticsMode === "done") return cell.status === 2;
    if(analyticsMode === "open") return cell.status !== 2;
    return true;
  }

  function getWeekStats(w){
    // counts by category + completion rate
    const byCat = {};
    let total = 0;
    let done = 0;

    w.tasks.forEach(row => {
      Object.values(row).forEach(cell => {
        if(!cell) return;
        if(!inMode(cell)) return;

        total++;
        if(cell.status === 2) done++;

        const cat = extractCategory(cell.text);
        byCat[cat] = (byCat[cat] || 0) + 1;
      });
    });

    const pct = total ? Math.round((done / total) * 100) : 0;
    return { total, done, pct, byCat };
  }

  const analyticsData = useMemo(() => {
    const filtered = analyticsWeeks.filter(w => {
      if(!rangeStart || !rangeEnd) return true;
      return w.key >= rangeStart && w.key <= rangeEnd;
    });

    const perWeek = filtered.map(w => {
      const s = getWeekStats(w.week);
      return { weekKey: w.key, ...s };
    });

    // top categories overall (for charts)
    const overall = {};
    perWeek.forEach(w => {
      Object.entries(w.byCat).forEach(([k,v]) => {
        overall[k] = (overall[k] || 0) + v;
      });
    });

    const top5 = Object.entries(overall)
      .sort((a,b)=>b[1]-a[1])
      .slice(0,5)
      .map(([k])=>k);

    const top10 = Object.entries(overall)
      .sort((a,b)=>b[1]-a[1])
      .slice(0,10)
      .map(([k])=>k);

    return { perWeek, top5, top10 };
  }, [analyticsWeeks, rangeStart, rangeEnd, analyticsMode]);

  function Stacked100Chart({ perWeek, topCats, showLine=true }) {
    const W = 860, H = 260;
    const padL = 42, padR = 18, padT = 14, padB = 40;

    const innerW = W - padL - padR;
    const innerH = H - padT - padB;

    const n = perWeek.length || 1;
    const barGap = 6;
    const barW = Math.max(10, (innerW - barGap*(n-1)) / n);

    const colors = ["#2563eb","#16a34a","#f59e0b","#ef4444","#a855f7","#64748b"]; // top5 + others
    const othersLabel = "Others";

    const stacks = perWeek.map(w => {
      const total = Object.values(w.byCat).reduce((a,b)=>a+b,0);
      const items = topCats.map((c, i) => ({ cat: c, val: w.byCat[c] || 0, color: colors[i] }));
      const used = items.reduce((a,b)=>a+b.val,0);
      const oth = Math.max(0, total - used);
      items.push({ cat: othersLabel, val: oth, color: colors[Math.min(colors.length-1, topCats.length)] });
      return { weekKey: w.weekKey, total, pct: w.pct, items };
    });

    const linePts = stacks.map((s, i) => {
      const x = padL + i*(barW+barGap) + barW/2;
      const y = padT + innerH - (s.pct/100)*innerH;
      return { x, y, pct: s.pct };
    });

    const linePath = linePts.map((p,i)=> `${i===0?'M':'L'} ${p.x.toFixed(2)} ${p.y.toFixed(2)}`).join(" ");

    return (
      <div className="w-full">
        <svg width="100%" viewBox={`0 0 ${W} ${H}`} className="block bg-white rounded-lg border border-gray-200">
          {/* y axis labels 0/50/100 */}
          {[0,50,100].map(v=>{
            const y = padT + innerH - (v/100)*innerH;
            return (
              <g key={v}>
                <line x1={padL} y1={y} x2={W-padR} y2={y} stroke="#e5e7eb" strokeWidth="1" />
                <text x={padL-8} y={y+4} textAnchor="end" fontSize="10" fill="#6b7280">{v}%</text>
              </g>
            );
          })}

          {/* stacked bars */}
          {stacks.map((s, i) => {
            const x = padL + i*(barW+barGap);
            let yTop = padT + innerH;
            return (
              <g key={s.weekKey}>
                {s.items.map((it, j) => {
                  const h = s.total ? (it.val / s.total) * innerH : 0;
                  const y = yTop - h;
                  yTop = y;
                  return (
                    <rect
                      key={j}
                      x={x}
                      y={y}
                      width={barW}
                      height={h}
                      fill={it.color}
                      opacity={it.val===0 ? 0 : 0.85}
                    />
                  );
                })}
                <text
                  x={x + barW/2}
                  y={H-16}
                  textAnchor="middle"
                  fontSize="10"
                  fill="#374151"
                >
                  {s.weekKey}
                </text>
              </g>
            );
          })}

          {/* completion line + integer labels */}
          {showLine && (
            <g>
              <path d={linePath} fill="none" stroke="#111827" strokeWidth="2" />
              {linePts.map((p, i)=>(
                <g key={i}>
                  <circle cx={p.x} cy={p.y} r="3" fill="#111827" />
                  <text x={p.x} y={p.y-8} textAnchor="middle" fontSize="10" fill="#111827">
                    {p.pct}%
                  </text>
                </g>
              ))}
            </g>
          )}
        </svg>

        {/* legend */}
        <div className="flex flex-wrap gap-3 mt-2 text-xs text-gray-700">
          {topCats.map((c, i)=>(
            <div key={c} className="flex items-center gap-2">
              <span className="inline-block w-3 h-3 rounded-sm" style={{background: ["#2563eb","#16a34a","#f59e0b","#ef4444","#a855f7"][i]}}></span>
              <span>{c}</span>
            </div>
          ))}
          <div className="flex items-center gap-2">
            <span className="inline-block w-3 h-3 rounded-sm" style={{background:"#64748b"}}></span>
            <span>Others</span>
          </div>
          <div className="flex items-center gap-2">
            <span className="inline-block w-8 h-[2px]" style={{background:"#111827"}}></span>
            <span>Weekly completion %</span>
          </div>
        </div>
      </div>
    );
  }

  function Top10SmallChart({ perWeek, top10 }) {
    // aggregate over selected weeks
    const agg = {};
    let total = 0;
    perWeek.forEach(w=>{
      Object.entries(w.byCat).forEach(([k,v])=>{
        agg[k] = (agg[k]||0)+v;
        total += v;
      });
    });

    const top = top10.map(k => ({ k, v: agg[k] || 0 }));
    const used = top.reduce((a,b)=>a+b.v,0);
    const others = Math.max(0, total - used);

    const series = [...top, { k: "Others", v: others }].filter(x => x.v > 0 || x.k === "Others");
    const maxV = Math.max(1, ...series.map(s=>s.v));

    return (
      <div className="bg-white rounded-lg border border-gray-200 p-3">
        <div className="text-sm font-semibold text-gray-800 mb-2">Top 10 categories (selected weeks)</div>
        <div className="space-y-2">
          {series.map((s, i)=>{
            const pct = total ? Math.round((s.v/total)*100) : 0;
            return (
              <div key={s.k} className="flex items-center gap-2">
                <div className="w-40 text-xs text-gray-700 truncate" title={s.k}>{s.k}</div>
                <div className="flex-1 h-3 bg-gray-100 rounded">
                  <div className="h-3 rounded" style={{ width: `${(s.v/maxV)*100}%`, background: "#2563eb", opacity: s.k==="Others"?0.35:0.8 }} />
                </div>
                <div className="w-10 text-xs text-gray-800 text-right">{pct}%</div>
              </div>
            );
          })}
        </div>
      </div>
    );
  }

  /* ---------- UI ---------- */
  return (
    <div className="p-1 bg-white min-h-screen">
      <div className="bg-white w-full">
        {/* Tabs */}
        <div className="flex items-center gap-2 px-2 py-2 border-b border-gray-200">
          <button
            onClick={()=>setActiveTab('organizer')}
            className={`px-4 py-2 rounded-md text-sm font-medium transition ${
              activeTab==='organizer'
                ? 'bg-blue-600 text-white shadow'
                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
            }`}
          >
            Weekly Organizer
          </button>

          <button
            onClick={()=>setActiveTab('summary')}
            className={`px-4 py-2 rounded-md text-sm font-medium transition ${
              activeTab==='summary'
                ? 'bg-blue-600 text-white shadow'
                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
            }`}
          >
            Monthly Summary
          </button>

          <button
            onClick={()=>setActiveTab('analytics')}
            className={`px-4 py-2 rounded-md text-sm font-medium transition ${
              activeTab==='analytics'
                ? 'bg-blue-600 text-white shadow'
                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
            }`}
          >
            Analytics
          </button>

          <div className="ml-auto flex gap-2">
            <button onClick={saveToFile} className="bg-green-600 hover:bg-green-700 text-white px-3 py-2 rounded">Save</button>
            <button onClick={()=>fileInputRef.current?.click()} className="bg-purple-600 hover:bg-purple-700 text-white px-3 py-2 rounded">Load</button>
            <input ref={fileInputRef} type="file" accept=".json" className="hidden" onChange={loadFromFile} />
            {activeTab==='organizer' && (
              <button onClick={addNewWeek} className="bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded">Add Week</button>
            )}
          </div>
        </div>

        {activeTab==='organizer' ? (
          <div>
            {weeks.map((week)=>{
              const year = week.year || currentYear;
              const wkNum = Number(week.weekNumber) || currentWeek;
              const monday = getDateOfISOWeek(wkNum, year);
              const dates = [
                monday,
                new Date(monday.getFullYear(), monday.getMonth(), monday.getDate()+1),
                new Date(monday.getFullYear(), monday.getMonth(), monday.getDate()+2),
                new Date(monday.getFullYear(), monday.getMonth(), monday.getDate()+3),
                new Date(monday.getFullYear(), monday.getMonth(), monday.getDate()+4)
              ];

              let todayColIndex = -1;
              dates.forEach((d,i)=>{
                const key = `${d.getFullYear()}-${d.getMonth()}-${d.getDate()}`;
                if(key === todayKey) todayColIndex = i + 2;
              });

              return (
                <table key={week.id} className="w-full border-collapse mb-2">
                  <thead>
                    <tr>
                      <th
                        className="text-white text-center px-1 py-[2px] text-[10px]"
                        style={{
                          background: todayColIndex===0 ? '#3b82f6' : '#374151',
                          borderLeft: todayColIndex===0 ? '3px solid #2563eb' : '0',
                          borderRight: todayColIndex===0 ? '3px solid #2563eb' : '0',
                          whiteSpace: 'nowrap',
                          width: '120px'
                        }}
                      >
                        W-
                        <input
                          value={week.weekNumber}
                          onChange={(e)=> updateWeekNumber(week.id, parseInt(e.target.value) || 0)}
                          className="w-8 text-xs font-semibold bg-transparent border-b border-gray-300 focus:outline-none text-white text-center"
                          title="Click to edit week number"
                        />{" "}
                        / Deleg.
                      </th>

                      <th className="text-white text-center px-2 py-1 text-xs" style={{ background:'#374151', whiteSpace:'nowrap' }}>
                        Weekly Objectives
                      </th>

                      {["Monday","Tuesday","Wednesday","Thursday","Friday"].map((day,i)=>{
                        const idx = i + 2;
                        const isToday = idx === todayColIndex;
                        return (
                          <th
                            key={day}
                            className="text-white text-center px-2 py-1 text-xs"
                            style={{
                              background: isToday ? '#3b82f6' : '#374151',
                              borderLeft: isToday ? '3px solid #2563eb' : '0',
                              borderRight: isToday ? '3px solid #2563eb' : '0',
                              whiteSpace:'nowrap'
                            }}
                          >
                            {day} ({formatDayShort(dates[i])})
                          </th>
                        );
                      })}
                    </tr>
                  </thead>

                  <tbody>
                    {week.tasks.map((task,rowIndex)=>(
                      <tr key={rowIndex}>
                        {["delegatedTasks","weeklyObjectives","monday","tuesday","wednesday","thursday","friday"].map((col,colIndex)=>{
                          const style = getCellStyle(col, rowIndex, task[col].text);
                          const isToday = colIndex === todayColIndex;
                          const leftBorder = colIndex === 0 ? '0' : '1px solid rgba(0,0,0,0.06)';
                          const cellBorderLeft = isToday ? '3px solid #2563eb' : leftBorder;
                          const cellBorderRight = isToday ? '3px solid #2563eb' : '0';

                          const cell = task[col];
                          const lines = Array.isArray(cell.lineStates) ? cell.lineStates : normalizeLineStates(cell).lineStates;
                          const lineHeightPx = 19.2; // matches 1.2rem

                          return (
                            <td
                              key={col}
                              onDragOver={(e) => {
                                e.preventDefault();
                                setDragOverRow({ weekId: week.id, rowIndex, col });
                              }}
                              onDragLeave={() => setDragOverRow(null)}
                              onDrop={(e) => {
                                handleDrop(e, week.id, rowIndex, col);
                                setDragOverRow(null);
                              }}
                              style={{
                                backgroundColor: style.bg,
                                borderLeft: cellBorderLeft,
                                borderRight: cellBorderRight,
                                verticalAlign:'top',
                                padding:'2px',
                                width: col === "delegatedTasks" ? "120px" : "auto",
                                outline: dragOverRow &&
                                         dragOverRow.weekId === week.id &&
                                         dragOverRow.rowIndex === rowIndex &&
                                         dragOverRow.col === col
                                         ? "2px dashed #2563eb"
                                         : "none",
                                outlineOffset: -2
                              }}
                            >
                              <div style={{ display:'flex', alignItems:'flex-start', gap:4 }}>
                                {/* Control stack: ranking + status */}
                                <div style={{
                                  width: 18,
                                  display: 'flex',
                                  flexDirection: 'column',
                                  alignItems: 'center',
                                  justifyContent: 'flex-start',
                                  gap: 2,
                                  opacity: style.ghost ? 0.4 : 1
                                }}>
                                  <input
                                    type="number"
                                    min="1"
                                    value={task[col].ranking}
                                    draggable
                                    onDragStart={()=>setDraggedItem({weekId:week.id,rowIndex,col})}
                                    onChange={(e)=>updateTask(week.id,rowIndex,col,'ranking', parseInt(e.target.value)||1)}
                                    style={{
                                      width: 16,
                                      height: 14,
                                      textAlign: 'center',
                                      fontSize: 9,
                                      lineHeight: '14px',
                                      background: 'transparent',
                                      color: style.text,
                                      border: 'none',
                                      outline: 'none',
                                      padding: 0,
                                      cursor: 'grab'
                                    }}
                                  />

                                  {/* 3-state status box */}
                                  <div
                                    onClick={() => {
                                      const nextStatus = ((task[col].status ?? 0) + 1) % 3; // 0â†’1â†’2â†’0
                                      updateTask(week.id, rowIndex, col, 'status', nextStatus);
                                    }}
                                    style={{
                                      width: 14,
                                      height: 14,
                                      borderRadius: 3,
                                      border: "1px solid #ccc",
                                      background:
                                        task[col].status === 0 ? "#fff" :
                                        task[col].status === 1 ? "#f97316" :
                                        "#22c55e",
                                      cursor: "pointer"
                                    }}
                                    title="Click: open â†’ ongoing â†’ done"
                                  />
                                </div>

                                {/* Textarea (unchanged behavior) + tiny per-line buttons (overlay) */}
                                <div style={{ flex:1, position:'relative' }}>
                                  <textarea
                                    value={task[col].text}
                                    onChange={(e)=>updateTask(week.id,rowIndex,col,'text',e.target.value)}
                                    onKeyDown={(e)=>handleKeyDown(e, week.id, rowIndex, colIndex)}
                                    ref={el=>{
                                      if(!inputRefs.current) inputRefs.current = {};
                                      inputRefs.current[`${week.id}-${rowIndex}-${colIndex}`] = el;
                                    }}
                                    placeholder={style.ghost ? "..." : "Task..."}
                                    style={{
                                      width:'100%',
                                      minHeight:20,
                                      resize:'none',
                                      overflow:'hidden',
                                      background:'transparent',
                                      color: task[col].status === 2
                                        ? (style.bg.includes("#dc2626") || style.bg.includes("#f97316") ? "#fff" : "#6b7280")
                                        : style.text,
                                      textDecoration: task[col].status === 2 ? "line-through" : "none",
                                      border:'none',
                                      outline:'none',
                                      fontSize:12,
                                      lineHeight:'1.2rem', // keep same as before
                                      fontStyle: style.ghost ? 'italic' : 'normal',
                                      paddingRight: 14 // reserve tiny space so buttons don't cover last characters
                                    }}
                                    onInput={(e)=>{
                                      e.target.style.height='auto';
                                      e.target.style.height=e.target.scrollHeight+'px';
                                    }}
                                  />

                                  {/* Tiny line completion buttons (no extra vertical space, no text duplication) */}
                                  {lines.map((ln, li)=>{
                                    // show for non-empty lines only
                                    if(!ln.text || ln.text.trim()==="") return null;
                                    const top = 2 + li*lineHeightPx;
                                    const done = !!ln.done;
                                    return (
                                      <div
                                        key={li}
                                        onMouseDown={(e)=>{ e.preventDefault(); e.stopPropagation(); }}
                                        onClick={(e)=>{ e.preventDefault(); e.stopPropagation(); toggleLine(week.id, rowIndex, col, li); }}
                                        title="Toggle line done"
                                        style={{
                                          position:'absolute',
                                          right: 2,
                                          top,
                                          width: 10,
                                          height: 10,
                                          borderRadius: 2,
                                          border: "1px solid #9ca3af",
                                          background: done ? "#22c55e" : "transparent",
                                          cursor: "pointer",
                                          opacity: (task[col].status===2) ? 0.7 : 1
                                        }}
                                      />
                                    );
                                  })}
                                </div>
                              </div>
                            </td>
                          );
                        })}
                      </tr>
                    ))}
                  </tbody>
                </table>
              );
            })}
          </div>
        ) : activeTab==='analytics' ? (
          <div className="p-4 bg-gray-50">
            <div className="flex flex-wrap items-center gap-3 mb-3">
              <div className="text-sm font-semibold text-gray-800">Mode:</div>
              <div className="flex gap-2">
                {[
                  {k:"all", label:"All entries"},
                  {k:"done", label:"Completed entries"},
                  {k:"open", label:"Uncompleted entries"},
                ].map(b=>(
                  <button
                    key={b.k}
                    onClick={()=>setAnalyticsMode(b.k)}
                    className={`px-3 py-1 rounded text-sm ${
                      analyticsMode===b.k ? "bg-blue-600 text-white" : "bg-white border border-gray-300 text-gray-700"
                    }`}
                  >
                    {b.label}
                  </button>
                ))}
              </div>

              <div className="ml-auto flex items-center gap-2">
                <div className="text-sm text-gray-600">Weeks:</div>
                <select
                  value={rangeStart || ""}
                  onChange={(e)=>setRangeStart(e.target.value)}
                  className="border border-gray-300 rounded px-2 py-1 text-sm bg-white"
                >
                  {analyticsWeeks.map(w=>(
                    <option key={w.key} value={w.key}>{w.key}</option>
                  ))}
                </select>
                <span className="text-gray-500">â†’</span>
                <select
                  value={rangeEnd || ""}
                  onChange={(e)=>setRangeEnd(e.target.value)}
                  className="border border-gray-300 rounded px-2 py-1 text-sm bg-white"
                >
                  {analyticsWeeks.map(w=>(
                    <option key={w.key} value={w.key}>{w.key}</option>
                  ))}
                </select>
              </div>
            </div>

            <div className="grid grid-cols-1 lg:grid-cols-3 gap-4">
              <div className="lg:col-span-2">
                <Stacked100Chart perWeek={analyticsData.perWeek} topCats={analyticsData.top5} />
              </div>
              <div>
                <Top10SmallChart perWeek={analyticsData.perWeek} top10={analyticsData.top10} />
              </div>
            </div>

            {/* Table: top10 + others per week (count + completion %) */}
            <div className="mt-4 bg-white rounded-lg border border-gray-200 overflow-x-auto">
              <div className="p-3 text-sm font-semibold text-gray-800">Weekly table (Top 10 + Others)</div>
              <table className="w-full border-collapse text-xs">
                <thead>
                  <tr className="bg-gray-100 text-gray-800">
                    <th className="p-2 text-left">Week</th>
                    {analyticsData.top10.map(c => (
                      <th key={c} className="p-2 text-left whitespace-nowrap">{c}</th>
                    ))}
                    <th className="p-2 text-left">Others</th>
                    <th className="p-2 text-center whitespace-nowrap">Completion %</th>
                  </tr>
                </thead>
                <tbody>
                  {analyticsData.perWeek.map(w=>{
                    // others calc
                    const total = Object.values(w.byCat).reduce((a,b)=>a+b,0);
                    const used = analyticsData.top10.reduce((a,k)=>a+(w.byCat[k]||0),0);
                    const others = Math.max(0, total-used);

                    return (
                      <tr key={w.weekKey} className="border-t">
                        <td className="p-2 font-medium text-gray-800 whitespace-nowrap">{w.weekKey}</td>
                        {analyticsData.top10.map(k=>{
                          const n = w.byCat[k] || 0;
                          return <td key={k} className="p-2 text-gray-700">{n}</td>;
                        })}
                        <td className="p-2 text-gray-700">{others}</td>
                        <td className="p-2 text-center text-gray-900">{w.pct}%</td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>
          </div>
        ) : (
          /* SUMMARY TAB */
          <div className="w-full p-3">
            <div className="flex items-center gap-3 mb-3">
              <label className="text-sm text-gray-600">Filter:</label>
              <select
                value={summaryFilter}
                onChange={(e)=>setSummaryFilter(e.target.value)}
                className="border border-gray-300 rounded px-2 py-1 text-sm"
              >
                <option>All</option>
                <option>Delegated</option>
                <option>Objectives</option>
                <option>Days</option>
              </select>

              <button
                onClick={addAllToNextWeekFromSummary}
                className="ml-auto flex items-center gap-2 bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded"
                title="Add all open tasks below to the next week's Weekly Objectives (creates it if needed)."
              >
                Add All to Next Week
              </button>
            </div>

            <div className="overflow-x-auto">
              <table className="w-full" style={{ borderCollapse:'collapse' }}>
                <thead>
                  <tr className="bg-gray-700 text-white text-sm">
                    <th className="p-2 text-center">Week</th>
                    <th className="p-2 text-center">Year</th>
                    <th className="p-2 text-center">Column</th>
                    <th className="p-2 text-center">Task</th>
                    <th className="p-2 text-center">Copied</th>
                  </tr>
                </thead>
                <tbody>
                  {summaryRows.length === 0 ? (
                    <tr>
                      <td colSpan="5" className="p-4 text-center text-gray-500">No open tasks ðŸŽ‰</td>
                    </tr>
                  ) : summaryRows.map(row => (
                    <tr key={row.key} className="border-b border-gray-200">
                      <td className="p-2 text-center">{row.weekNumber}</td>
                      <td className="p-2 text-center">{row.year}</td>
                      <td className="p-2 text-center">{row.colLabel}</td>
                      <td className="p-2">{row.text}</td>
                      <td className="p-2 text-center">{copiedKeys.has(row.key) ? 'âœ“' : ''}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        )}

      </div>
    </div>
  );
}

/* ---------- boot ---------- */
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<WeeklyTaskOrganizer />);
</script>
</body>
</html>
