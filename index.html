<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Weekly Task Organizer</title>

  <!-- React + Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Lucide (icons) -->
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>

  <style>
    /* small visual tweaks */
    body { margin: 0; }
    /* make table cells align top */
    table td, table th { vertical-align: top; }
    /* subtle vertical separators: we will set inline for columns; this is fallback */
    .col-sep { border-left: 1px solid rgba(0,0,0,0.06); }
    /* highlight border thickness for current column - applied inline per column */
  </style>
</head>
<body class="bg-gray-100 min-h-screen">
  <div id="root"></div>

<script type="text/babel">
const { useState, useEffect, useRef } = React;

/* ---------- ISO week helpers ---------- */
function getISOWeekAndYear(date) {
  const tmp = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
  tmp.setUTCDate(tmp.getUTCDate() + 4 - (tmp.getUTCDay() || 7));
  const yearStart = new Date(Date.UTC(tmp.getUTCFullYear(),0,1));
  const weekNo = Math.ceil((((tmp - yearStart) / 86400000) + 1)/7);
  return [weekNo, tmp.getUTCFullYear()];
}
function getDateOfISOWeek(week, year) {
  const jan4 = new Date(Date.UTC(year, 0, 4));
  const jan4Day = jan4.getUTCDay() || 7;
  const monday = new Date(jan4);
  monday.setUTCDate(jan4.getUTCDate() - (jan4Day - 1) + (week - 1) * 7);
  return new Date(monday.getUTCFullYear(), monday.getUTCMonth(), monday.getUTCDate());
}
function formatDayShort(d) {
  const dd = String(d.getDate()).padStart(2,'0');
  const monthNames = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
  return dd + '/' + monthNames[d.getMonth()];
}

/* ---------- tasks/week defaults ---------- */
function makeEmptyTasks() {
  return Array(16).fill(null).map((_, i) => ({
    delegatedTasks: { text: "", completed: false, ranking: i+1 },
    weeklyObjectives: { text: "", completed: false, ranking: i+1 },
    monday: { text: "", completed: false, ranking: i+1 },
    tuesday: { text: "", completed: false, ranking: i+1 },
    wednesday: { text: "", completed: false, ranking: i+1 },
    thursday: { text: "", completed: false, ranking: i+1 },
    friday: { text: "", completed: false, ranking: i+1 }
  }));
}

/* compute current week/year for defaults */
const [currentWeek, currentYear] = getISOWeekAndYear(new Date());

/* ---------- Main Component ---------- */
function WeeklyTaskOrganizer() {
  // initialize from localStorage or default single week
  const initial = () => {
    const saved = localStorage.getItem('weekly-task-organizer');
    if (saved) {
      try { return JSON.parse(saved); } catch {}
    }
    return [{
      id: Date.now(),
      weekNumber: currentWeek,
      year: currentYear,
      tasks: makeEmptyTasks()
    }];
  };

  const [weeks, setWeeks] = useState(initial);
  const [draggedItem, setDraggedItem] = useState(null);
  const inputRefs = useRef({});
  const fileInputRef = useRef(null);
  const rowRefs = useRef({}); // { weekId: [ [tdRef,col0], [..] ] }

  const columns = ["delegatedTasks","weeklyObjectives","monday","tuesday","wednesday","thursday","friday"];
  const columnLabels = ["Delegated Tasks","Weekly Objectives","Monday","Tuesday","Wednesday","Thursday","Friday"];

  /* cell colors */
  function getWeeklyObjectivesColor(i){
    if(i<=3) return { bg:"#dc2626", text:"white" };
    if(i<=7) return { bg:"#f97316", text:"white" };
    if(i<=11) return { bg:"#facc15", text:"black" };
    return { bg:"#fde68a", text:"black" };
  }
  function getDayColumnColor(i){
    if(i===0) return { bg:"#dc2626", text:"white" };
    if(i<=3) return { bg:"#fcd34d", text:"black" };
    if(i>=14) return { bg:"#eff6ff", text:"black" };
    return { bg:"#ffffff", text:"black" };
  }
  function getCellStyle(col, rowIndex){
    if(col === 'weeklyObjectives') return getWeeklyObjectivesColor(rowIndex);
    if(col === 'delegatedTasks') return { bg:"#ffffff", text:"black" };
    return getDayColumnColor(rowIndex);
  }

  function getCategoryRange(col, rowIndex){
    if(col === 'weeklyObjectives'){
      if(rowIndex <= 3) return [0,3];
      if(rowIndex <= 7) return [4,7];
      if(rowIndex <= 11) return [8,11];
      return [12,15];
    }
    if(col === 'delegatedTasks') return [0,15];
    if(rowIndex === 0) return [0,0];
    if(rowIndex <= 3) return [1,3];
    if(rowIndex <= 13) return [4,13];
    return [14,15];
  }

  function sortColumnByCategory(tasks, col){
    const newTasks = [...tasks];
    const ranges = [
      getCategoryRange(col,0),
      getCategoryRange(col,4),
      getCategoryRange(col,8),
      getCategoryRange(col,12)
    ];
    ranges.forEach(([start,end])=>{
      const seg = [];
      for(let i=start;i<=end;i++) seg.push({task:newTasks[i][col]});
      const incomplete = seg.filter(s=>!s.task.completed).sort((a,b)=>a.task.ranking-b.task.ranking);
      const complete = seg.filter(s=>s.task.completed).sort((a,b)=>a.task.ranking-b.task.ranking);
      const merged = [...incomplete,...complete];
      merged.forEach((it, idx)=> {
        newTasks[start + idx] = { ...newTasks[start + idx], [col]: it.task };
      });
    });
    return newTasks;
  }

  function updateTask(weekId, rowIndex, col, field, value){
    // special handling: when field === 'text' from an Alt+Enter injection we will set caret manually in handler
    setWeeks(prev => prev.map(w => {
      if(w.id !== weekId) return w;
      let newTasks = [...w.tasks];
      newTasks[rowIndex] = { ...newTasks[rowIndex], [col]: { ...newTasks[rowIndex][col], [field]: value } };
      newTasks = sortColumnByCategory(newTasks, col);
      return { ...w, tasks: newTasks };
    }));
  }

  /* Drag & drop */
  function handleDragStart(e, weekId, rowIndex, col){
    setDraggedItem({ weekId, rowIndex, col });
    e.dataTransfer.effectAllowed = 'move';
  }
  function handleDrop(e, weekId, targetRow, col){
    e.preventDefault();
    if(!draggedItem || draggedItem.weekId !== weekId || draggedItem.col !== col){ setDraggedItem(null); return; }
    setWeeks(prev => prev.map(w => {
      if(w.id !== weekId) return w;
      const tasks = [...w.tasks];
      const tmp = tasks[draggedItem.rowIndex][col];
      tasks[draggedItem.rowIndex][col] = tasks[targetRow][col];
      tasks[targetRow][col] = tmp;
      return { ...w, tasks: sortColumnByCategory(tasks, col) };
    }));
    setDraggedItem(null);
  }

  /* keyboard navigation and Alt+Enter newline handling */
  function focusCell(weekId, row, col){
    if(row < 0 || col < 0 || col >= columns.length || row >= 16) return;
    const key = `${weekId}-${row}-${col}`;
    const el = inputRefs.current[key];
    if(el) el.focus();
  }

  function handleKeyDown(e, weekId, row, col){
    // Alt+Enter should insert newline into same cell
    if(e.key === 'Enter' && e.altKey){
      // insert newline at caret in the textarea
      const key = `${weekId}-${row}-${col}`;
      const el = inputRefs.current[key];
      if(el){
        e.preventDefault();
        const start = el.selectionStart || 0;
        const end = el.selectionEnd || 0;
        const val = el.value || '';
        const newVal = val.slice(0,start) + '\n' + val.slice(end);
        updateTask(weekId, row, col, 'text', newVal);
        // set caret after inserted newline
        setTimeout(()=> {
          el.selectionStart = el.selectionEnd = start + 1;
        }, 0);
      }
      return;
    }

    // Normal navigation behavior:
    if(e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); focusCell(weekId, row+1, col); }
    else if(e.key === 'Enter' && e.shiftKey){ e.preventDefault(); focusCell(weekId, row-1, col); }
    else if(e.key === 'Tab' && !e.shiftKey){ e.preventDefault(); focusCell(weekId, row, col+1); }
    else if(e.key === 'Tab' && e.shiftKey){ e.preventDefault(); focusCell(weekId, row, col-1); }
  }

  /* add / delete weeks (carry over open in first two columns) */
  function addNewWeek(){
    const prev = weeks[0];
    const nowYear = new Date().getFullYear();
    const nextNum = prev && typeof prev.weekNumber === 'number' ? prev.weekNumber + 1 : currentWeek;
    const newWeek = { id: Date.now(), weekNumber: nextNum, year: nowYear, tasks: makeEmptyTasks() };

    if(prev){
      const openDel = prev.tasks.filter(t => t.delegatedTasks.text.trim() && !t.delegatedTasks.completed);
      const openObj = prev.tasks.filter(t => t.weeklyObjectives.text.trim() && !t.weeklyObjectives.completed);
      openDel.forEach((t, idx) => { if(idx < 16) newWeek.tasks[idx].delegatedTasks = { ...t.delegatedTasks, completed:false }; });
      openObj.forEach((t, idx) => { if(idx < 16) newWeek.tasks[idx].weeklyObjectives = { ...t.weeklyObjectives, completed:false }; });
    }
    setWeeks([newWeek, ...weeks]);
  }
  function deleteWeek(id){
    if(weeks.length <= 1) return;
    setWeeks(weeks.filter(w => w.id !== id));
  }

  /* save/load */
  function saveToFile(){
    const blob = new Blob([JSON.stringify(weeks, null, 2)], { type: 'application/json' });
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
    a.download = `weekly-organizer-${new Date().toISOString().split('T')[0]}.json`;
    a.click(); URL.revokeObjectURL(a.href);
  }
  function loadFromFile(e){
    const f = e.target.files?.[0]; if(!f) return;
    const r = new FileReader();
    r.onload = ev => {
      try { setWeeks(JSON.parse(ev.target.result)); } catch { alert('Invalid file'); }
    };
    r.readAsText(f);
  }

  /* update week number inline */
  function updateWeekNumber(weekId, newNumber){
    setWeeks(prev => prev.map(w => w.id === weekId ? { ...w, weekNumber: newNumber } : w));
  }

  /* autosave */
  useEffect(()=> {
    try { localStorage.setItem('weekly-task-organizer', JSON.stringify(weeks)); } catch {}
  }, [weeks]);

  /* render lucide icons */
  useEffect(()=> lucide.createIcons());

  /* auto-resize rows per week */
  useEffect(()=>{
    weeks.forEach(wk => {
      const byRow = rowRefs.current[wk.id];
      if(!byRow) return;
      byRow.forEach((cells, rIdx) => {
        if(!cells) return;
        let max = 0;
        cells.forEach(c => { if(c) max = Math.max(max, c.scrollHeight); });
        cells.forEach(c => { if(c) c.style.height = (max || 20) + 'px'; });
      });
    });
  }, [weeks]);

  function ensureRowRefs(weekId, rowIndex){
    if(!rowRefs.current[weekId]) rowRefs.current[weekId] = [];
    if(!rowRefs.current[weekId][rowIndex]) rowRefs.current[weekId][rowIndex] = [];
  }

  /* today detection for highlight (local date) */
  const today = new Date();
  const todayYMD = `${today.getFullYear()}-${today.getMonth()}-${today.getDate()}`;

  /* ---------- render ---------- */
  return (
    <div className="w-full">
      {/* Full-bleed white frame (we remove horizontal margins to maximize width) */}
      <div style={{ width: '100%', background: '#fff', boxSizing: 'border-box' }}>
        <div className="flex justify-between items-center p-4 border-b border-gray-200">
          <h1 className="text-2xl font-bold text-gray-800">Weekly Task Organizer</h1>
          <div className="flex gap-2">
            <button onClick={saveToFile} className="flex items-center gap-2 bg-green-600 hover:bg-green-700 text-white px-3 py-2 rounded">
              <i data-lucide="save" className="w-4 h-4"></i> Save
            </button>
            <button onClick={()=>fileInputRef.current?.click()} className="flex items-center gap-2 bg-purple-600 hover:bg-purple-700 text-white px-3 py-2 rounded">
              <i data-lucide="upload" className="w-4 h-4"></i> Load
            </button>
            <input ref={fileInputRef} type="file" accept=".json" className="hidden" onChange={loadFromFile} />
            <button onClick={addNewWeek} className="flex items-center gap-2 bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded">
              <i data-lucide="plus" className="w-4 h-4"></i> Add Week
            </button>
          </div>
        </div>

        {/* Weeks stack with no vertical gap (headers touch previous table rows) */}
        <div>
          {weeks.map((week, wIdx) => {
            const year = week.year || currentYear;
            const wkNum = Number(week.weekNumber) || currentWeek;
            const monday = getDateOfISOWeek(wkNum, year);
            const dates = [
              monday,
              new Date(monday.getFullYear(), monday.getMonth(), monday.getDate() + 1),
              new Date(monday.getFullYear(), monday.getMonth(), monday.getDate() + 2),
              new Date(monday.getFullYear(), monday.getMonth(), monday.getDate() + 3),
              new Date(monday.getFullYear(), monday.getMonth(), monday.getDate() + 4)
            ];

            // find today column index for this week, if any
            let todayColIndex = -1;
            dates.forEach((d,i) => {
              const key = `${d.getFullYear()}-${d.getMonth()}-${d.getDate()}`;
              if(key === todayYMD) todayColIndex = i + 2; // monday maps to columns index 2 in columns array
            });

            return (
              <div key={week.id} style={{ width: '100%' }}>
                {/* header: week number inline in delegated tasks header area */}
                <div className="flex items-center justify-between px-4 py-2" style={{ background:'#fff' }}>
                  <div className="flex items-center gap-3">
                    <span className="text-sm text-gray-600">Week</span>
                    <input
                      value={week.weekNumber}
                      onChange={(e)=> updateWeekNumber(week.id, parseInt(e.target.value) || 0)}
                      className="w-20 text-lg font-semibold bg-transparent border-b border-gray-300 focus:outline-none text-gray-800 text-center"
                      title="Click to edit week number"
                    />
                    <span className="text-sm text-gray-600">/ Delegated Tasks</span>
                  </div>
                  <div>
                    {weeks.length > 1 && (
                      <button onClick={()=>deleteWeek(week.id)} className="flex items-center gap-2 bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded text-sm">
                        <i data-lucide="trash-2" className="w-4 h-4"></i> Delete
                      </button>
                    )}
                  </div>
                </div>

                {/* table (full width) */}
                <div style={{ overflowX: 'auto' }}>
                  <table className="w-full" style={{ borderCollapse: 'collapse' }}>
                    <thead>
                      <tr>
                        {columnLabels.map((label, idx) => {
                          // compute a style for header: if it's a day and matches todayColIndex -> highlight
                          let thStyle = { background: '#374151', color: '#fff', padding: '10px', textAlign: 'left', fontSize: '13px' };
                          if(idx >= 2 && idx <= 6 && (idx === todayColIndex)) {
                            thStyle = { ...thStyle, background: '#3b82f6', boxShadow: 'inset 0 0 0 2px rgba(59,130,246,0.12)', borderLeft: '3px solid #2563eb', borderRight: '3px solid #2563eb' };
                          }

                          // date text inline for weekdays
                          let dateText = '';
                          if(idx >= 2 && idx <= 6) {
                            const d = dates[idx - 2];
                            dateText = ` (${formatDayShort(d)})`;
                          }

                          return (
                            <th key={label} style={thStyle}>
                              <div style={{ display:'flex', alignItems:'center', gap:8 }}>
                                <span>{label}{dateText}</span>
                              </div>
                            </th>
                          );
                        })}
                      </tr>
                    </thead>

                    <tbody>
                      {week.tasks.map((task, rowIndex) => (
                        <tr key={rowIndex}>
                          {columns.map((col, colIndex) => {
                            const style = getCellStyle(col, rowIndex);
                            ensureRowRefs(week.id, rowIndex);
                            // vertical separators: add left border except first column
                            const leftBorder = colIndex === 0 ? '0' : '1px solid rgba(0,0,0,0.06)';
                            // if this column is the highlighted today column, make thicker borders left/right
                            const isTodayCol = (colIndex === todayColIndex);
                            const cellBorderLeft = isTodayCol ? '3px solid #2563eb' : leftBorder;
                            const cellBorderRight = isTodayCol ? '3px solid #2563eb' : '0';

                            return (
                              <td
                                key={col}
                                draggable
                                onDragStart={(e) => handleDragStart(e, week.id, rowIndex, col)}
                                onDragOver={(e) => e.preventDefault()}
                                onDrop={(e) => handleDrop(e, week.id, rowIndex, col)}
                                ref={el => { rowRefs.current[week.id][rowIndex][colIndex] = el; }}
                                style={{
                                  backgroundColor: style.bg,
                                  color: style.text === 'white' ? '#fff' : '#000',
                                  padding: '6px',
                                  borderLeft: cellBorderLeft,
                                  borderRight: cellBorderRight,
                                  verticalAlign: 'top'
                                }}
                              >
                                <div style={{ display: 'flex', gap: 8 }}>
                                  {/* Narrow left column for ranking above checkbox */}
                                  <div style={{ minWidth: 44, display:'flex', flexDirection:'column', alignItems:'flex-start', gap:4 }}>
                                    <input
                                      type="number"
                                      min="1"
                                      value={task[col].ranking}
                                      onChange={(e) => updateTask(week.id, rowIndex, col, 'ranking', parseInt(e.target.value) || 1)}
                                      className="text-xs"
                                      style={{ width: 36, textAlign:'center', background: style.bg, color: style.text === 'white' ? '#fff' : '#000', border: 'none', outline:'none' }}
                                    />
                                    <input
                                      type="checkbox"
                                      checked={task[col].completed}
                                      onChange={(e) => updateTask(week.id, rowIndex, col, 'completed', e.target.checked)}
                                      style={{ width: 16, height: 16, marginTop: 2 }}
                                    />
                                  </div>

                                  {/* textarea grows to occupy rest of row */}
                                  <div style={{ flex:1 }}>
                                    <textarea
                                      value={task[col].text}
                                      onChange={(e) => updateTask(week.id, rowIndex, col, 'text', e.target.value)}
                                      onKeyDown={(e) => handleKeyDown(e, week.id, rowIndex, colIndex)}
                                      ref={el => { inputRefs.current[`${week.id}-${rowIndex}-${colIndex}`] = el; }}
                                      placeholder="Task..."
                                      style={{
                                        width: '100%',
                                        minHeight: 20,
                                        resize: 'none',
                                        overflow: 'hidden',
                                        background: style.bg,
                                        color: style.text === 'white' ? '#fff' : '#000',
                                        border: 'none',
                                        outline: 'none',
                                        fontSize: 12,
                                        lineHeight: '1.2rem'
                                      }}
                                      onInput={(e) => { e.target.style.height = 'auto'; e.target.style.height = e.target.scrollHeight + 'px'; }}
                                    />
                                  </div>
                                </div>
                              </td>
                            );
                          })}
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </div>
            );
          })}
        </div>
      </div>
    </div>
  );
}

/* ---------- boot ---------- */
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<WeeklyTaskOrganizer />);
</script>
</body>
</html>
