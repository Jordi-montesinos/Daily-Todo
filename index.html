<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Weekly Task Organizer</title>

  <!-- React -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    body { margin:0 }
    td, th { vertical-align: top; }
    textarea { line-height: 1.2rem; }
    /* hide default number input spinners */
    input[type=number]::-webkit-outer-spin-button,
    input[type=number]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    input[type=number] { -moz-appearance: textfield; }
  </style>
</head>

<body class="bg-gray-100">
<div id="root"></div>

<script type="text/babel">
const { useState, useEffect, useMemo, useRef } = React;

/* ---------- helpers ---------- */
function getISOWeek(date){
  const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
  d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay()||7));
  const y = d.getUTCFullYear();
  const w = Math.ceil((((d - new Date(Date.UTC(y,0,1))) / 86400000) + 1) / 7);
  return [w,y];
}

function extractCategory(text){
  const t = (text || "").trim();
  if(!t) return "Other";
  const m = t.match(/^(.+?)\s*-\s*/);
  return m ? m[1].trim() : "Other";
}

function clampStatus(s){
  const n = Number(s);
  return (n===0 || n===1 || n===2) ? n : 0;
}

function isBlankText(t){
  return !t || !t.trim();
}

/* Per-cell: keep subStatuses aligned with lines (excluding first line).
   No text duplication: textarea remains the source of truth. */
function syncSubStatuses(cell){
  const text = (cell.text || "");
  const lines = text.split("\n"); // keep empty lines while editing
  const subLineCount = Math.max(0, lines.length - 1);

  const prev = Array.isArray(cell.subStatuses) ? cell.subStatuses.map(clampStatus) : [];
  const next = [];
  for(let i=0;i<subLineCount;i++){
    next.push(prev[i] ?? 0);
  }
  return { ...cell, subStatuses: next };
}

/* ---------- defaults ---------- */
function makeEmptyTasks(){
  return Array.from({length:16}, (_,i)=>( {
    delegatedTasks:{text:"",status:0,ranking:i+1, subStatuses:[]},
    weeklyObjectives:{text:"",status:0,ranking:i+1, subStatuses:[]},
    monday:{text:"",status:0,ranking:i+1, subStatuses:[]},
    tuesday:{text:"",status:0,ranking:i+1, subStatuses:[]},
    wednesday:{text:"",status:0,ranking:i+1, subStatuses:[]},
    thursday:{text:"",status:0,ranking:i+1, subStatuses:[]},
    friday:{text:"",status:0,ranking:i+1, subStatuses:[]}
  }));
}

/* ---------- chart label plugin (integer labels on line points) ---------- */
const LinePointLabelPlugin = {
  id: 'linePointLabels',
  afterDatasetsDraw(chart, args, pluginOptions){
    const { ctx } = chart;
    const opts = pluginOptions || {};
    const datasetIndex = opts.datasetIndex ?? 0;
    const color = opts.color ?? '#111827';
    const fontSize = opts.fontSize ?? 11;

    const meta = chart.getDatasetMeta(datasetIndex);
    if(!meta || meta.hidden) return;

    ctx.save();
    ctx.fillStyle = color;
    ctx.font = `${fontSize}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';

    meta.data.forEach((point, i) => {
      const v = chart.data.datasets[datasetIndex].data[i];
      if(v === null || v === undefined) return;
      const x = point.x;
      const y = point.y;
      ctx.fillText(`${Math.round(v)}%`, x, y - 6);
    });

    ctx.restore();
  }
};

/* ---------- MAIN APP ---------- */
function App(){
  const [currentWeek, currentYear] = getISOWeek(new Date());

  // storage
  const STORAGE_KEY = "weekly-task-organizer";

  const [weeks, setWeeks] = useState(()=>{
    const saved = localStorage.getItem(STORAGE_KEY);
    if(saved){
      try{
        const parsed = JSON.parse(saved);

        // migrate older shapes (completed -> status, ensure subStatuses exist)
        parsed.forEach(w=>{
          (w.tasks||[]).forEach(row=>{
            Object.keys(row||{}).forEach(col=>{
              const cell = row[col];
              if(!cell) return;
              if(cell.status === undefined && cell.completed !== undefined){
                cell.status = cell.completed ? 2 : 0;
                delete cell.completed;
              }
              cell.status = clampStatus(cell.status);
              if(cell.ranking === undefined) cell.ranking = 1;
              if(!Array.isArray(cell.subStatuses)) cell.subStatuses = [];
              row[col] = syncSubStatuses(cell);
            });
          });
        });

        return parsed;
      } catch {}
    }
    return [{
      id: Date.now(),
      weekNumber: currentWeek,
      year: currentYear,
      tasks: makeEmptyTasks()
    }];
  });

  // autosave to localStorage (no file popup here)
  useEffect(()=>{
    try{
      localStorage.setItem(STORAGE_KEY, JSON.stringify(weeks));
    } catch {}
  }, [weeks]);

  const [tab, setTab] = useState("organizer");

  const columns = ["delegatedTasks","weeklyObjectives","monday","tuesday","wednesday","thursday","friday"];
  const dayCols = ["monday","tuesday","wednesday","thursday","friday"];

  // editing state: only used to render textarea vs "view mode"
  const [editing, setEditing] = useState(null); // {weekId,row,col} or null
  const isEditing = (weekId,row,col) =>
    editing && editing.weekId===weekId && editing.row===row && editing.col===col;

  function updateCell(weekId, rowIndex, col, patchFn){
    setWeeks(ws=>ws.map(w=>{
      if(w.id!==weekId) return w;
      const tasks = [...w.tasks];
      const cell = tasks[rowIndex][col];
      const nextCell = patchFn(cell);
      tasks[rowIndex] = { ...tasks[rowIndex], [col]: nextCell };
      return { ...w, tasks };
    }));
  }

  function cycleMainStatus(weekId,row,col){
    updateCell(weekId,row,col,(cell)=>{
      const next = { ...cell, status: (clampStatus(cell.status)+1)%3 };
      return next;
    });
  }

  function cycleSubStatus(weekId,row,col,subIdx){
    updateCell(weekId,row,col,(cell)=>{
      const subs = Array.isArray(cell.subStatuses) ? [...cell.subStatuses] : [];
      subs[subIdx] = (clampStatus(subs[subIdx] ?? 0) + 1) % 3;
      return { ...cell, subStatuses: subs };
    });
  }

  // keep subStatuses aligned after editing (on blur)
  function finalizeTextEdit(weekId,row,col){
    updateCell(weekId,row,col,(cell)=>syncSubStatuses(cell));
  }

  // colors (minimal, keep your existing scheme idea; adjust if needed)
  function getWeeklyObjectivesColor(i){
    if(i<=3) return { bg:"#dc2626", text:"white" };
    if(i<=7) return { bg:"#f97316", text:"white" };
    if(i<=11) return { bg:"#facc15", text:"black" };
    return { bg:"#fde68a", text:"black" };
  }
  function getDayColumnColor(i){
    if(i===0) return { bg:"#dc2626", text:"white" };
    if(i<=3) return { bg:"#fcd34d", text:"black" };
    if(i>=14) return { bg:"#eff6ff", text:"black" };
    return { bg:"#ffffff", text:"black" };
  }
  function getCellBaseStyle(col,rowIndex){
    if(col === "weeklyObjectives") return getWeeklyObjectivesColor(rowIndex);
    if(col === "delegatedTasks") return { bg:"#ffffff", text:"black" };
    return getDayColumnColor(rowIndex);
  }

  function buttonBg(status){
    if(status===0) return "#fff";
    if(status===1) return "#f97316";
    return "#22c55e";
  }

  function mainTextColorForCompleted(baseBg){
    // On red/orange backgrounds completed grey is unreadable -> force white.
    const bg = (baseBg || "").toLowerCase();
    if(bg.includes("#dc2626") || bg.includes("#f97316")) return "#fff";
    return "#6b7280";
  }

  /* ---------- analytics model ---------- */
  const analyticsModel = useMemo(()=>{
    // Each "line" counts as an entry.
    // First line uses cell.status; subsequent lines use cell.subStatuses[i-1].
    // Monday–Friday only.
    const weeksSorted = [...weeks].slice().sort((a,b)=>{
      if(a.year!==b.year) return a.year-b.year;
      return (a.weekNumber||0)-(b.weekNumber||0);
    });

    const rows = weeksSorted.map(w=>{
      const cats = {}; // cat -> { open, done, total }
      let total = 0;
      let done = 0;
      let open = 0;

      (w.tasks||[]).forEach(r=>{
        dayCols.forEach(col=>{
          const cell = r[col];
          if(!cell) return;
          const text = cell.text || "";
          if(isBlankText(text)) return;

          const lines = text.split("\n");
          // first line
          const first = (lines[0] ?? "").trim();
          if(first){
            const cat = extractCategory(first);
            cats[cat] = cats[cat] || { open:0, done:0, total:0 };
            total++; cats[cat].total++;
            if(clampStatus(cell.status)===2){ done++; cats[cat].done++; }
            else { open++; cats[cat].open++; }
          }
          // sub lines
          const subs = Array.isArray(cell.subStatuses) ? cell.subStatuses : [];
          for(let i=1;i<lines.length;i++){
            const line = (lines[i] ?? "").trim();
            if(!line) continue;
            const cat = extractCategory(line);
            cats[cat] = cats[cat] || { open:0, done:0, total:0 };
            total++; cats[cat].total++;
            const st = clampStatus(subs[i-1] ?? 0);
            if(st===2){ done++; cats[cat].done++; }
            else { open++; cats[cat].open++; }
          }
        });
      });

      const completionPct = total ? (done/total)*100 : 0;

      return {
        key: `${w.year}-W${w.weekNumber}`,
        year: w.year,
        week: w.weekNumber,
        label: `W${w.weekNumber}`,
        cats,
        total,
        done,
        open,
        completionPct
      };
    });

    return rows;
  }, [weeks]);

  // Week range for analytics slicer
  const weekKeys = analyticsModel.map(r=>r.key);
  const [rangeFrom, setRangeFrom] = useState(()=>weekKeys[0] || "");
  const [rangeTo, setRangeTo] = useState(()=>weekKeys[weekKeys.length-1] || "");

  useEffect(()=>{
    // keep valid when weeks change
    const keys = analyticsModel.map(r=>r.key);
    if(keys.length===0) return;
    if(!keys.includes(rangeFrom)) setRangeFrom(keys[0]);
    if(!keys.includes(rangeTo)) setRangeTo(keys[keys.length-1]);
  }, [analyticsModel]);

  const selectedRows = useMemo(()=>{
    if(analyticsModel.length===0) return [];
    const keys = analyticsModel.map(r=>r.key);
    const iFrom = Math.max(0, keys.indexOf(rangeFrom));
    const iTo = Math.max(0, keys.indexOf(rangeTo));
    const a = Math.min(iFrom, iTo);
    const b = Math.max(iFrom, iTo);
    return analyticsModel.slice(a, b+1);
  }, [analyticsModel, rangeFrom, rangeTo]);

  // toggle for stacked bars
  const [stackMode, setStackMode] = useState("all"); // all | done | open

  function valueByMode(v){
    if(stackMode==="done") return v.done;
    if(stackMode==="open") return v.open;
    return v.total;
  }

  // compute Top5 (for main chart) across selected range, then build week series
  const chartData = useMemo(()=>{
    const agg = {}; // cat -> count (depending on mode)
    selectedRows.forEach(r=>{
      Object.entries(r.cats).forEach(([cat,v])=>{
        agg[cat] = (agg[cat]||0) + valueByMode(v);
      });
    });
    const top5 = Object.entries(agg)
      .sort((a,b)=>b[1]-a[1])
      .slice(0,5)
      .map(([k])=>k);

    const labels = selectedRows.map(r=>r.label);

    // build 100% stacks for each top5 + Others
    const series = {};
    top5.forEach(c=> series[c] = []);
    series["Others"] = [];

    selectedRows.forEach(r=>{
      const totalThisWeek = Object.values(r.cats).reduce((s,v)=>s + valueByMode(v), 0);
      const denom = totalThisWeek || 1;

      let sumTop = 0;
      top5.forEach(c=>{
        const v = r.cats[c] ? valueByMode(r.cats[c]) : 0;
        sumTop += v;
        series[c].push((v/denom)*100);
      });

      const others = Math.max(0, totalThisWeek - sumTop);
      series["Others"].push((others/denom)*100);
    });

    // completion line should be weekly completion% over ALL tasks (independent of stackMode)
    const completionLine = selectedRows.map(r=>r.completionPct);

    return { labels, top5, series, completionLine };
  }, [selectedRows, stackMode]);

  // Small chart: Top10+Others across selected range as a single 100% column
  const smallChartData = useMemo(()=>{
    const aggAll = {}; // cat -> count by mode across range
    selectedRows.forEach(r=>{
      Object.entries(r.cats).forEach(([cat,v])=>{
        aggAll[cat] = (aggAll[cat]||0) + valueByMode(v);
      });
    });
    const top10 = Object.entries(aggAll)
      .sort((a,b)=>b[1]-a[1])
      .slice(0,10)
      .map(([k])=>k);

    const total = Object.values(aggAll).reduce((s,v)=>s+v,0) || 1;
    const topSum = top10.reduce((s,k)=>s + (aggAll[k]||0),0);
    const others = Math.max(0, total - topSum);

    const labels = ["Selected range"];
    const series = {};
    top10.forEach(k=>{
      series[k] = [((aggAll[k]||0)/total)*100];
    });
    series["Others"] = [(others/total)*100];

    return { labels, top10, series };
  }, [selectedRows, stackMode]);

  // Table: Top10 + Others per week, with Open & Done counts
  const tableModel = useMemo(()=>{
    const aggAll = {};
    selectedRows.forEach(r=>{
      Object.entries(r.cats).forEach(([cat,v])=>{
        aggAll[cat] = (aggAll[cat]||0) + v.total; // ranking top10 by total across range
      });
    });
    const top10 = Object.entries(aggAll)
      .sort((a,b)=>b[1]-a[1])
      .slice(0,10)
      .map(([k])=>k);

    const rows = selectedRows.map(r=>{
      const out = { label: r.label };
      let othersOpen=0, othersDone=0;

      top10.forEach(cat=>{
        const v = r.cats[cat] || { open:0, done:0, total:0 };
        out[`${cat}__open`] = v.open;
        out[`${cat}__done`] = v.done;
      });

      Object.entries(r.cats).forEach(([cat,v])=>{
        if(top10.includes(cat)) return;
        othersOpen += v.open;
        othersDone += v.done;
      });

      out[`Others__open`] = othersOpen;
      out[`Others__done`] = othersDone;

      return out;
    });

    return { top10, rows };
  }, [selectedRows]);

  /* ---------- CHARTS (refs + effects) ---------- */
  const mainChartRef = useRef(null);
  const smallChartRef = useRef(null);
  const mainChartInstance = useRef(null);
  const smallChartInstance = useRef(null);

  useEffect(()=>{
    if(tab!=="analytics") return;

    // destroy old
    if(mainChartInstance.current){
      mainChartInstance.current.destroy();
      mainChartInstance.current = null;
    }

    const canvas = mainChartRef.current;
    if(!canvas) return;

    const categories = [...chartData.top5, "Others"];
    const datasets = categories.map((cat, idx)=>({
      type: 'bar',
      label: cat,
      data: chartData.series[cat] || [],
      borderWidth: 1,
      stack: 'stack1',
      yAxisID: 'y'
    }));

    // completion line on y2
    datasets.push({
      type: 'line',
      label: 'Completion %',
      data: chartData.completionLine,
      yAxisID: 'y2',
      tension: 0.25,
      pointRadius: 3
    });

    mainChartInstance.current = new Chart(canvas, {
      data: {
        labels: chartData.labels,
        datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { position: 'top' },
          tooltip: { mode: 'index', intersect: false },
          linePointLabels: { datasetIndex: datasets.length - 1, fontSize: 11 }
        },
        interaction: { mode: 'index', intersect: false },
        scales: {
          y: {
            stacked: true,
            min: 0,
            max: 100,
            ticks: {
              callback: (v)=> `${v}%`
            },
            title: { display: true, text: 'Category share (100%)' }
          },
          y2: {
            position: 'right',
            min: 0,
            max: 100,
            grid: { drawOnChartArea: false },
            ticks: {
              callback: (v)=> `${v}%`
            },
            title: { display: true, text: 'Completion %' }
          },
          x: {
            stacked: true
          }
        }
      },
      plugins: [LinePointLabelPlugin]
    });

    return ()=> {
      if(mainChartInstance.current){
        mainChartInstance.current.destroy();
        mainChartInstance.current = null;
      }
    };
  }, [tab, chartData]);

  useEffect(()=>{
    if(tab!=="analytics") return;

    if(smallChartInstance.current){
      smallChartInstance.current.destroy();
      smallChartInstance.current = null;
    }

    const canvas = smallChartRef.current;
    if(!canvas) return;

    const categories = [...smallChartData.top10, "Others"];
    const datasets = categories.map((cat)=>({
      type: 'bar',
      label: cat,
      data: smallChartData.series[cat] || [0],
      borderWidth: 1,
      stack: 'stackSmall',
      yAxisID: 'y'
    }));

    smallChartInstance.current = new Chart(canvas, {
      type: 'bar',
      data: {
        labels: smallChartData.labels,
        datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { position: 'top' },
          tooltip: { mode: 'index', intersect: false }
        },
        scales: {
          y: {
            stacked: true,
            min: 0,
            max: 100,
            ticks: { callback: (v)=>`${v}%` }
          },
          x: { stacked: true }
        }
      }
    });

    return ()=> {
      if(smallChartInstance.current){
        smallChartInstance.current.destroy();
        smallChartInstance.current = null;
      }
    };
  }, [tab, smallChartData]);

  /* ---------- UI helpers: render view-mode lines with buttons ---------- */
  function renderViewCell(week, rowIndex, col){
    const cell = week.tasks[rowIndex][col];
    const base = getCellBaseStyle(col, rowIndex);
    const lines = (cell.text || "").split("\n");
    const firstLine = (lines[0] ?? "");
    const subLines = lines.slice(1);

    const bigStatus = clampStatus(cell.status);
    const bigBg = buttonBg(bigStatus);

    const mainTextColor = bigStatus === 2 ? mainTextColorForCompleted(base.bg) : base.text;

    return (
      <div className="flex gap-2">
        {/* left stack: big button only (aligned top) */}
        <div style={{ width: 20, display:'flex', flexDirection:'column', alignItems:'center', gap: 4 }}>
          <div
            onClick={()=>cycleMainStatus(week.id, rowIndex, col)}
            title="Toggle task status"
            style={{
              width: 18,
              height: 18,
              borderRadius: 3,
              border: "1px solid #cbd5e1",
              background: bigBg,
              cursor: "pointer",
              display:'flex',
              alignItems:'center',
              justifyContent:'center',
              fontSize: 10,
              fontWeight: 700,
              color: bigStatus===2 ? "#fff" : "#111827",
              lineHeight: "18px"
            }}
          >
            {cell.ranking}
          </div>
        </div>

        {/* right: text lines (exactly as before visually; no duplication) */}
        <div style={{ flex: 1, display:'flex', flexDirection:'column', gap: 0 }}>
          {/* first line */}
          <div
            style={{
              fontSize: 12,
              lineHeight: "1.2rem",
              whiteSpace: "pre-wrap",
              wordBreak: "break-word",
              color: mainTextColor,
              textDecoration: bigStatus===2 ? "line-through" : "none",
              minHeight: 20
            }}
          >
            {firstLine}
          </div>

          {/* sub lines: small buttons on the left */}
          {subLines.map((ln, i)=>{
            const st = clampStatus((cell.subStatuses || [])[i] ?? 0);
            const subColor = st===2 ? "#6b7280" : base.text;
            const subBg = buttonBg(st);

            return (
              <div key={i} className="flex items-start gap-2">
                <div style={{ width: 20, display:'flex', justifyContent:'center' }}>
                  <div
                    onClick={()=>cycleSubStatus(week.id, rowIndex, col, i)}
                    title="Toggle subtask status"
                    style={{
                      width: 12,
                      height: 12,
                      borderRadius: 3,
                      border: "1px solid #cbd5e1",
                      background: subBg,
                      cursor: "pointer",
                      marginTop: 2
                    }}
                  />
                </div>
                <div
                  style={{
                    fontSize: 12,
                    lineHeight: "1.2rem",
                    whiteSpace: "pre-wrap",
                    wordBreak: "break-word",
                    color: st===2 ? subColor : base.text,
                    textDecoration: st===2 ? "line-through" : "none",
                    minHeight: 18
                  }}
                >
                  {ln}
                </div>
              </div>
            );
          })}
        </div>
      </div>
    );
  }

  function renderEditCell(week, rowIndex, col){
    const cell = week.tasks[rowIndex][col];
    const base = getCellBaseStyle(col, rowIndex);
    const st = clampStatus(cell.status);
    const mainTextColor = st===2 ? mainTextColorForCompleted(base.bg) : base.text;

    return (
      <div className="flex gap-2">
        {/* big button stays (aligned top) */}
        <div style={{ width: 20, display:'flex', flexDirection:'column', alignItems:'center', gap: 4 }}>
          <div
            onClick={()=>cycleMainStatus(week.id, rowIndex, col)}
            title="Toggle task status"
            style={{
              width: 18,
              height: 18,
              borderRadius: 3,
              border: "1px solid #cbd5e1",
              background: buttonBg(st),
              cursor: "pointer",
              display:'flex',
              alignItems:'center',
              justifyContent:'center',
              fontSize: 10,
              fontWeight: 700,
              color: st===2 ? "#fff" : "#111827",
              lineHeight: "18px"
            }}
          >
            {cell.ranking}
          </div>
        </div>

        {/* textarea: behaves like before (Alt+Enter is just newline) */}
        <div style={{ flex: 1 }}>
          <textarea
            value={cell.text}
            onChange={(e)=>{
              const v = e.target.value;
              updateCell(week.id, rowIndex, col, (c)=>({ ...c, text: v }));
            }}
            onBlur={()=>{
              finalizeTextEdit(week.id, rowIndex, col);
              setEditing(null);
            }}
            onKeyDown={(e)=>{
              // keep Alt+Enter default newline behaviour
              // do not prevent Enter here; user wants "as before"
            }}
            className="w-full resize-none outline-none text-xs"
            style={{
              background: "transparent",
              color: mainTextColor,
              textDecoration: st===2 ? "line-through" : "none",
              border: "none",
              padding: 0,
              margin: 0
            }}
            rows={Math.max(1, (cell.text || "").split("\n").length)}
          />
        </div>
      </div>
    );
  }

  const firstWeek = weeks[0];

  return (
    <div className="p-2">

      {/* Tabs */}
      <div className="flex gap-2 mb-2">
        <button
          onClick={()=>setTab("organizer")}
          className={tab==="organizer" ? "bg-blue-600 text-white px-3 py-1 rounded" : "bg-gray-200 px-3 py-1 rounded"}
        >
          Organizer
        </button>
        <button
          onClick={()=>setTab("analytics")}
          className={tab==="analytics" ? "bg-blue-600 text-white px-3 py-1 rounded" : "bg-gray-200 px-3 py-1 rounded"}
        >
          Analytics
        </button>
      </div>

      {/* Organizer */}
      {tab==="organizer" && (
        <table className="w-full border-collapse bg-white">
          <thead>
            <tr className="bg-gray-700 text-white text-xs">
              <th className="w-[160px] p-1 text-left">W-{firstWeek.weekNumber}</th>
              <th className="p-1 text-left">Objectives</th>
              <th className="p-1 text-left">Mon</th>
              <th className="p-1 text-left">Tue</th>
              <th className="p-1 text-left">Wed</th>
              <th className="p-1 text-left">Thu</th>
              <th className="p-1 text-left">Fri</th>
            </tr>
          </thead>
          <tbody>
            {firstWeek.tasks.map((row,ri)=>(
              <tr key={ri}>
                {columns.map(col=>{
                  const base = getCellBaseStyle(col, ri);
                  const cell = row[col];
                  const ghost = isBlankText(cell.text);

                  return (
                    <td
                      key={col}
                      className="border"
                      style={{
                        background: ghost ? (base.bg + "33") : base.bg,
                        padding: "2px",
                        color: base.text
                      }}
                      onDoubleClick={()=>{
                        setEditing({ weekId: firstWeek.id, row: ri, col });
                      }}
                      onClick={()=>{
                        // single click: focus edit when empty (optional). keep conservative:
                        // if user wants, they can double click to edit.
                      }}
                    >
                      {isEditing(firstWeek.id, ri, col)
                        ? renderEditCell(firstWeek, ri, col)
                        : renderViewCell(firstWeek, ri, col)
                      }
                    </td>
                  );
                })}
              </tr>
            ))}
          </tbody>
        </table>
      )}

      {/* Analytics */}
      {tab==="analytics" && (
        <div className="bg-white p-3 rounded shadow-sm">
          <div className="flex flex-wrap items-center gap-3 mb-3">
            <div className="text-sm font-semibold">Analytics (Mon→Fri only)</div>

            <div className="ml-auto flex flex-wrap items-center gap-2">
              <div className="text-xs text-gray-600">Range:</div>
              <select className="border rounded px-2 py-1 text-xs" value={rangeFrom} onChange={e=>setRangeFrom(e.target.value)}>
                {analyticsModel.map(r=>(<option key={r.key} value={r.key}>{r.label} ({r.year})</option>))}
              </select>
              <div className="text-xs text-gray-600">→</div>
              <select className="border rounded px-2 py-1 text-xs" value={rangeTo} onChange={e=>setRangeTo(e.target.value)}>
                {analyticsModel.map(r=>(<option key={r.key} value={r.key}>{r.label} ({r.year})</option>))}
              </select>

              <div className="ml-3 flex items-center gap-1">
                <button
                  className={stackMode==="all" ? "bg-blue-600 text-white px-2 py-1 rounded text-xs" : "bg-gray-200 px-2 py-1 rounded text-xs"}
                  onClick={()=>setStackMode("all")}
                >All</button>
                <button
                  className={stackMode==="done" ? "bg-blue-600 text-white px-2 py-1 rounded text-xs" : "bg-gray-200 px-2 py-1 rounded text-xs"}
                  onClick={()=>setStackMode("done")}
                >Completed</button>
                <button
                  className={stackMode==="open" ? "bg-blue-600 text-white px-2 py-1 rounded text-xs" : "bg-gray-200 px-2 py-1 rounded text-xs"}
                  onClick={()=>setStackMode("open")}
                >Uncompleted</button>
              </div>
            </div>
          </div>

          <div className="grid grid-cols-1 lg:grid-cols-3 gap-3">
            {/* main chart */}
            <div className="lg:col-span-2">
              <div className="text-sm font-semibold mb-2">Weekly trend</div>
              <div style={{ height: 320 }}>
                <canvas ref={mainChartRef}></canvas>
              </div>
              <div className="text-xs text-gray-600 mt-1">
                Bars = category share (Top 5 + Others) for the selected mode. Line = completion % (all tasks).
              </div>
            </div>

            {/* small chart */}
            <div>
              <div className="text-sm font-semibold mb-2">Top 10 share (selected range)</div>
              <div style={{ height: 320 }}>
                <canvas ref={smallChartRef}></canvas>
              </div>
              <div className="text-xs text-gray-600 mt-1">
                100% stacked, Top 10 + Others (selected mode).
              </div>
            </div>
          </div>

          {/* table */}
          <div className="mt-4">
            <div className="text-sm font-semibold mb-2">Weekly table (Top 10 + Others)</div>
            <div className="overflow-x-auto border rounded">
              <table className="min-w-max border-collapse bg-white">
                <thead>
                  <tr className="bg-gray-700 text-white text-xs">
                    <th className="p-2 sticky left-0 bg-gray-700">Week</th>
                    {tableModel.top10.map(cat=>(
                      <React.Fragment key={cat}>
                        <th className="p-2 text-center">{cat} Open</th>
                        <th className="p-2 text-center">{cat} Done</th>
                      </React.Fragment>
                    ))}
                    <th className="p-2 text-center">Others Open</th>
                    <th className="p-2 text-center">Others Done</th>
                  </tr>
                </thead>
                <tbody>
                  {tableModel.rows.map((r, idx)=>(
                    <tr key={idx} className="border-b text-xs">
                      <td className="p-2 sticky left-0 bg-white font-semibold">{r.label}</td>
                      {tableModel.top10.map(cat=>(
                        <React.Fragment key={cat}>
                          <td className="p-2 text-center">{r[`${cat}__open`] ?? 0}</td>
                          <td className="p-2 text-center">{r[`${cat}__done`] ?? 0}</td>
                        </React.Fragment>
                      ))}
                      <td className="p-2 text-center">{r[`Others__open`] ?? 0}</td>
                      <td className="p-2 text-center">{r[`Others__done`] ?? 0}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>

        </div>
      )}

      <div className="text-xs text-gray-500 mt-2">
        Tip: double-click a cell to edit. Click buttons to cycle status (white → orange → green).
      </div>

    </div>
  );
}

/* ---------- render ---------- */
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
</script>
</body>
</html>
