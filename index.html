<!DOCTYPE html>
<html lang="en"> 
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Weekly Task Organizer</title>

  <!-- React + Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    body { margin: 0; }
    table td, table th { vertical-align: top; }

    /* hide default number input spinners */
    input[type=number]::-webkit-outer-spin-button,
    input[type=number]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    input[type=number] { -moz-appearance: textfield; }

    /* keep compact without shrinking main font size */
    textarea { line-height: 1.2rem; }
  </style>
</head>

<body class="bg-gray-100 min-h-screen">
  <div id="root"></div>

<script type="text/babel">
const { useState, useEffect, useRef, useMemo } = React;

/* -----------------------------
   ISO week helpers
------------------------------ */
function getISOWeekAndYear(date) {
  const tmp = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
  tmp.setUTCDate(tmp.getUTCDate() + 4 - (tmp.getUTCDay() || 7));
  const yearStart = new Date(Date.UTC(tmp.getUTCFullYear(), 0, 1));
  const weekNo = Math.ceil((((tmp - yearStart) / 86400000) + 1) / 7);
  return [weekNo, tmp.getUTCFullYear()];
}

function getDateOfISOWeek(week, year) {
  const jan4 = new Date(Date.UTC(year, 0, 4));
  const jan4Day = jan4.getUTCDay() || 7;
  const monday = new Date(jan4);
  monday.setUTCDate(jan4.getUTCDate() - (jan4Day - 1) + (week - 1) * 7);
  return new Date(monday.getUTCFullYear(), monday.getUTCMonth(), monday.getUTCDate());
}

function formatDayShort(d) {
  const dd = String(d.getDate()).padStart(2,'0');
  const monthNames = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
  return dd + '/' + monthNames[d.getMonth()];
}

/* -----------------------------
   Defaults
   status: 0=open, 1=ongoing (orange), 2=done (green)
------------------------------ */
function makeEmptyCell(ranking){
  return { text:"", status:0, ranking, subtasks: [] };
}

function makeEmptyTasks() {
  return Array(16).fill(null).map((_, i) => ({
    delegatedTasks:   makeEmptyCell(i+1),
    weeklyObjectives: makeEmptyCell(i+1),
    monday:           makeEmptyCell(i+1),
    tuesday:          makeEmptyCell(i+1),
    wednesday:        makeEmptyCell(i+1),
    thursday:         makeEmptyCell(i+1),
    friday:           makeEmptyCell(i+1),
  }));
}

/* -----------------------------
   Migration (old -> new)
------------------------------ */
function migrateLoadedWeeks(parsed){
  if(!Array.isArray(parsed)) return null;

  parsed.forEach(week => {
    if(!Array.isArray(week.tasks)) return;
    week.tasks.forEach(row => {
      Object.keys(row).forEach(col => {
        const cell = row[col];
        if(!cell || typeof cell !== "object") return;

        if(cell.status === undefined && cell.completed !== undefined){
          cell.status = cell.completed ? 2 : 0;
          delete cell.completed;
        }
        if(cell.status === undefined) cell.status = 0;
        if(cell.ranking === undefined) cell.ranking = 1;
        if(!Array.isArray(cell.subtasks)) cell.subtasks = [];
        if(typeof cell.text !== "string") cell.text = String(cell.text ?? "");
      });
    });
  });

  return parsed;
}

/* -----------------------------
   Common helpers
------------------------------ */
function isBlankCell(cell){
  return !cell || !cell.text || cell.text.trim() === "";
}

function nextStatus(s){
  const v = (s ?? 0);
  return (v + 1) % 3;
}

/* -----------------------------
   Categories: "xxx - yyy"
   Default renamed to avoid "Other" vs "Others" confusion
------------------------------ */
function extractCategory(text){
  const t = (text || "").trim();
  const idx = t.indexOf(" - ");
  if(idx > 0) return t.slice(0, idx).trim();
  return "Uncategorized";
}

/* -----------------------------
   Chart helper: integer % labels on line points
------------------------------ */
const LinePointLabelPlugin = {
  id: 'linePointLabels',
  afterDatasetsDraw(chart, args, pluginOptions) {
    const { ctx } = chart;
    const idx = pluginOptions?.datasetIndex;
    if(idx === undefined) return;

    const meta = chart.getDatasetMeta(idx);
    if(!meta || meta.hidden) return;

    ctx.save();
    ctx.font = '12px sans-serif';
    ctx.fillStyle = '#111827';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';

    meta.data.forEach((pt, i) => {
      const val = chart.data.datasets[idx].data[i];
      if(val === null || val === undefined) return;
      ctx.fillText(`${Math.round(val)}%`, pt.x, pt.y - 6);
    });

    ctx.restore();
  }
};

/* -----------------------------
   Main App
------------------------------ */
const [currentWeek, currentYear] = getISOWeekAndYear(new Date());

function WeeklyTaskOrganizer() {
  /* ---------- init ---------- */
  const initial = () => {
    const saved = localStorage.getItem('weekly-task-organizer');
    if(saved){
      try {
        const parsed = JSON.parse(saved);
        const migrated = migrateLoadedWeeks(parsed);
        if(migrated) return migrated;
      } catch {}
    }
    return [{
      id: Date.now(),
      weekNumber: currentWeek,
      year: currentYear,
      tasks: makeEmptyTasks()
    }];
  };

  const [weeks, setWeeks] = useState(initial);
  const [activeTab, setActiveTab] = useState('organizer');
  const [showAllWeeks, setShowAllWeeks] = useState(false);
  const saveDebounceRef = useRef(null);


  const [draggedItem, setDraggedItem] = useState(null);
  const [dragOverCell, setDragOverCell] = useState(null);

  const inputRefs = useRef({});
  const fileInputRef = useRef(null);

  const columns = ["delegatedTasks","weeklyObjectives","monday","tuesday","wednesday","thursday","friday"];
  const dayColsForAnalytics = ["monday","tuesday","wednesday","thursday","friday"];

  /* ---------- analytics controls ---------- */
  const [stackMode, setStackMode] = useState('all'); // all | done | open
  const [rangeFrom, setRangeFrom] = useState(0);
  const [rangeTo, setRangeTo] = useState(0);

  /* ---------- chart refs ---------- */
  const mainChartRef = useRef(null);
  const miniChartRef = useRef(null);
  const mainChartInstance = useRef(null);
  const miniChartInstance = useRef(null);

  /* ---------- colors ---------- */
  function getWeeklyObjectivesColor(i){
    if(i<=3) return { bg:"#dc2626", text:"white" };
    if(i<=7) return { bg:"#f97316", text:"white" };
    if(i<=11) return { bg:"#facc15", text:"black" };
    return { bg:"#fde68a", text:"black" };
  }
  function getDayColumnColor(i){
    if(i===0) return { bg:"#dc2626", text:"white" };
    if(i<=3) return { bg:"#fcd34d", text:"black" };
    if(i>=14) return { bg:"#eff6ff", text:"black" };
    return { bg:"#ffffff", text:"black" };
  }
  function getCellBaseStyle(col, rowIndex){
    if(col === 'weeklyObjectives') return getWeeklyObjectivesColor(rowIndex);
    if(col === 'delegatedTasks') return { bg:"#ffffff", text:"black" };
    return getDayColumnColor(rowIndex);
  }
  function getCellStyle(col, rowIndex, text){
    const base = getCellBaseStyle(col, rowIndex);
    if(!text || text.trim()===""){
      return { bg: base.bg.includes("#") ? base.bg + "33" : "#f3f4f6", text:"#9ca3af", ghost:true };
    }
    return { ...base, ghost:false };
  }

  /* -----------------------------
     Category ranges
------------------------------ */
  function getCategoryRange(col, rowIndex){
    if(col === 'weeklyObjectives'){
      if(rowIndex <= 3) return [0,3];
      if(rowIndex <= 7) return [4,7];
      if(rowIndex <= 11) return [8,11];
      return [12,15];
    }
    if(col === 'delegatedTasks') return [0,15];
    if(rowIndex === 0) return [0,0];
    if(rowIndex <= 3) return [1,3];
    if(rowIndex <= 13) return [4,13];
    return [14,15];
  }

  function sortColumnByCategory(tasks, col) {
    const newTasks = [...tasks];
    const ranges = [ getCategoryRange(col,0), getCategoryRange(col,4), getCategoryRange(col,8), getCategoryRange(col,12) ];

    ranges.forEach(([start,end]) => {
      const seg = [];
      for (let i = start; i <= end; i++) seg.push(newTasks[i][col]);

      const filledOpen = seg.filter(c => c.text.trim() !== "" && c.status !== 2);
      const filledDone = seg.filter(c => c.text.trim() !== "" && c.status === 2);
      const blanks     = seg.filter(c => c.text.trim() === "");

      const merged = [...filledOpen, ...filledDone, ...blanks];

      for(let i=start; i<=end; i++){
        const idx = i - start;
        const normalized = { ...merged[idx], ranking: idx+1 };
        newTasks[i] = { ...newTasks[i], [col]: normalized };
      }
    });

    return newTasks;
  }

  function updateTask(weekId, rowIndex, col, field, value){
    setWeeks(prev => prev.map(w => {
      if(w.id !== weekId) return w;
      let newTasks = [...w.tasks];

      newTasks[rowIndex] = {
        ...newTasks[rowIndex],
        [col]: { ...newTasks[rowIndex][col], [field]: value }
      };

      if(field !== "text"){
        newTasks = sortColumnByCategory(newTasks, col);
      }

      return { ...w, tasks: newTasks };
    }));
  }

  function sortOneColumnNow(weekId, col){
    setWeeks(prev => prev.map(w => {
      if(w.id !== weekId) return w;
      return { ...w, tasks: sortColumnByCategory([...w.tasks], col) };
    }));
  }

  /* -----------------------------
     Auto-resize textareas
------------------------------ */


/* -----------------------------
   LocalStorage autosave (DEBOUNCED)
------------------------------ */
useEffect(() => {
  if (saveDebounceRef.current) clearTimeout(saveDebounceRef.current);

  saveDebounceRef.current = setTimeout(() => {
    try { localStorage.setItem('weekly-task-organizer', JSON.stringify(weeks)); } catch {}
  }, 600);

  return () => {
    if (saveDebounceRef.current) clearTimeout(saveDebounceRef.current);
  };
}, [weeks]);



  /* -----------------------------
     Save-to-file debounced (only if real changes since last save)
------------------------------ */
  const lastSavedFingerprint = useRef("");
  useEffect(() => {
  // baseline fingerprint so we don't auto-download if nothing changed after load
  lastSavedFingerprint.current = computeFingerprint(weeks);
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []);

  function computeFingerprint(obj){
    try { return JSON.stringify(obj); } catch { return String(Date.now()); }
  }
  function saveToFile(){
    const blob = new Blob([JSON.stringify(weeks, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    const todayStr = new Date().toISOString().split('T')[0];
    a.download = `weekly-organizer-${todayStr}.json`;
    a.click();
    URL.revokeObjectURL(a.href);
    lastSavedFingerprint.current = computeFingerprint(weeks);
  }
  useEffect(() => {
    const timer = setTimeout(() => {
      const fp = computeFingerprint(weeks);
      if(fp !== lastSavedFingerprint.current){
        saveToFile();
      }
    }, 2 * 60 * 1000);
    return () => clearTimeout(timer);
  }, [weeks]);

  /* -----------------------------
     Load from file
------------------------------ */
  function loadFromFile(e){
    const f = e.target.files?.[0];
    if(!f) return;
    const r = new FileReader();
    r.onload = ev => {
      try {
        const parsed = JSON.parse(ev.target.result);
        const migrated = migrateLoadedWeeks(parsed) || parsed;
        setWeeks(migrated);
        lastSavedFingerprint.current = computeFingerprint(migrated);
      } catch {
        alert('Invalid file');
      }
    };
    r.readAsText(f);
  }

  /* -----------------------------
     Add new week
------------------------------ */
  function addNewWeek(){
    const prev = weeks[0];
    const nowYear = new Date().getFullYear();
    const nextNum = prev && typeof prev.weekNumber === 'number' ? prev.weekNumber + 1 : currentWeek;

    const newWeek = { id: Date.now(), weekNumber: nextNum, year: nowYear, tasks: makeEmptyTasks() };

    if(prev){
      const openDel = prev.tasks.filter(t => t.delegatedTasks.text.trim() && t.delegatedTasks.status !== 2);
      const openObj = prev.tasks.filter(t => t.weeklyObjectives.text.trim() && t.weeklyObjectives.status !== 2);

      openDel.forEach((t, idx) => { if(idx < 16) newWeek.tasks[idx].delegatedTasks = { ...t.delegatedTasks, status:0 }; });
      openObj.forEach((t, idx) => { if(idx < 16) newWeek.tasks[idx].weeklyObjectives = { ...t.weeklyObjectives, status:0 }; });
    }

    setWeeks([newWeek, ...weeks]);
  }

  function updateWeekNumber(weekId, newNumber){
    setWeeks(prev => prev.map(w => w.id === weekId ? { ...w, weekNumber: newNumber } : w));
  }

  /* -----------------------------
     Drag highlight reset
------------------------------ */
  useEffect(() => {
    const onDropAnywhere = () => setDragOverCell(null);
    const onDragEnd = () => setDragOverCell(null);
    window.addEventListener('drop', onDropAnywhere);
    window.addEventListener('dragend', onDragEnd);
    return () => {
      window.removeEventListener('drop', onDropAnywhere);
      window.removeEventListener('dragend', onDragEnd);
    };
  }, []);

  /* -----------------------------
     Drag/drop cross-column
     - CTRL = copy
     - if target blank -> fill
     - if target filled -> shift down
------------------------------ */
  function handleDrop(e, weekId, targetRow, targetCol){
    e.preventDefault();
    if(!draggedItem || draggedItem.weekId !== weekId){
      setDraggedItem(null);
      return;
    }

    const isCopy = e.ctrlKey;

    setWeeks(prev => prev.map(w => {
      if(w.id !== weekId) return w;
      let tasks = [...w.tasks];

      const srcCol = draggedItem.col;
      const srcRow = draggedItem.rowIndex;

      const dragged = tasks[srcRow][srcCol];
      if(isBlankCell(dragged)) return w;

      if(!isCopy){
        tasks[srcRow] = { ...tasks[srcRow], [srcCol]: makeEmptyCell(srcRow+1) };
      }

      const targetCell = tasks[targetRow][targetCol];

      if(isBlankCell(targetCell)){
        tasks[targetRow] = { ...tasks[targetRow], [targetCol]: { ...dragged, ranking: targetRow+1 } };
      } else {
        for(let i = tasks.length - 1; i > targetRow; i--){
          tasks[i] = { ...tasks[i], [targetCol]: { ...tasks[i-1][targetCol], ranking: i+1 } };
        }
        tasks[targetRow] = { ...tasks[targetRow], [targetCol]: { ...dragged, ranking: targetRow+1 } };
      }

      tasks = sortColumnByCategory(tasks, targetCol);
      if(!isCopy) tasks = sortColumnByCategory(tasks, srcCol);

      return { ...w, tasks };
    }));

    setDraggedItem(null);
  }

  /* -----------------------------
     Keyboard nav + Enter sorting
------------------------------ */
  function focusCell(weekId, row, colIdx){
    if(row < 0 || colIdx < 0 || colIdx >= columns.length || row >= 16) return;
    const key = `${weekId}-${row}-${colIdx}`;
    const el = inputRefs.current[key];
    if(el) el.focus();
  }

  function handleKeyDown(e, weekId, row, colIdx){
    const col = columns[colIdx];

    if(e.key === 'Enter' && e.altKey){
      e.preventDefault();
      const el = e.target;
      const start = el.selectionStart;
      const end = el.selectionEnd;
      const next = el.value.slice(0, start) + '\n' + el.value.slice(end);
      el.value = next;
      el.selectionStart = el.selectionEnd = start + 1;
      updateTask(weekId, row, col, 'text', next);
      return;
    }

    if(e.key === 'Enter' && !e.shiftKey){
      e.preventDefault();
      sortOneColumnNow(weekId, col);
      focusCell(weekId, row+1, colIdx);
      return;
    }

    if(e.key === 'Enter' && e.shiftKey){
      e.preventDefault();
      focusCell(weekId, row-1, colIdx);
      return;
    }

    if(e.key === 'Tab' && !e.shiftKey){
      e.preventDefault();
      focusCell(weekId, row, colIdx+1);
      return;
    }

    if(e.key === 'Tab' && e.shiftKey){
      e.preventDefault();
      focusCell(weekId, row, colIdx-1);
      return;
    }
  }

  /* -----------------------------
     Subtask buttons aligned with lines
     - Use grid rows of 1.2rem to match textarea line-height
     - Row 0 = main big button, rows 1..n = small buttons
------------------------------ */
  function getLines(text){
    return (text || "").split("\n");
  }

  function ensureSubtasksLength(cell, lineCount){
    const need = Math.max(0, lineCount - 1);
    const existing = Array.isArray(cell.subtasks) ? cell.subtasks : [];
    if(existing.length === need) return cell;
    const next = existing.slice(0, need);
    while(next.length < need) next.push({ status:0 });
    return { ...cell, subtasks: next };
  }

  function toggleMainStatus(weekId, rowIndex, col){
    setWeeks(prev => prev.map(w => {
      if(w.id !== weekId) return w;
      const tasks = [...w.tasks];
      const cell = tasks[rowIndex][col];
      tasks[rowIndex] = { ...tasks[rowIndex], [col]: { ...cell, status: nextStatus(cell.status) } };
      return { ...w, tasks: sortColumnByCategory(tasks, col) };
    }));
  }

  function toggleSubStatus(weekId, rowIndex, col, subIdx){
    setWeeks(prev => prev.map(w => {
      if(w.id !== weekId) return w;
      const tasks = [...w.tasks];
      const cell = tasks[rowIndex][col];
      const lines = getLines(cell.text);
      const synced = ensureSubtasksLength(cell, lines.length);
      const subs = [...synced.subtasks];
      subs[subIdx] = { ...subs[subIdx], status: nextStatus(subs[subIdx].status) };
      tasks[rowIndex] = { ...tasks[rowIndex], [col]: { ...synced, subtasks: subs } };
      return { ...w, tasks };
    }));
  }

  function onCellBlur(weekId, rowIndex, col, finalText){
    setWeeks(prev => prev.map(w => {
      if(w.id !== weekId) return w;
      let tasks = [...w.tasks];
      const cell = tasks[rowIndex][col];
      const lines = getLines(finalText);
      const synced = ensureSubtasksLength({ ...cell, text: finalText }, lines.length);
      tasks[rowIndex] = { ...tasks[rowIndex], [col]: synced };
      tasks = sortColumnByCategory(tasks, col);
      return { ...w, tasks };
    }));
  }

  /* -----------------------------
     Analytics datasets
------------------------------ */
  const analyticsByWeek = useMemo(() => {
    const sorted = [...weeks].slice().reverse(); // oldest -> newest
    return sorted.map(w => {
      const bucket = {};
      let total = 0, done = 0;

      w.tasks.forEach(r => {
        dayColsForAnalytics.forEach(c => {
          const cell = r[c];
          if(!cell?.text?.trim()) return;

          const cat = extractCategory(cell.text);
          if(!bucket[cat]) bucket[cat] = { total:0, done:0, open:0 };

          bucket[cat].total += 1;
          total += 1;

          if(cell.status === 2){
            bucket[cat].done += 1;
            done += 1;
          } else {
            bucket[cat].open += 1;
          }
        });
      });

      const completionPct = total ? (done / total) * 100 : 0;

      return {
        id: w.id,
        label: `W${w.weekNumber}`,
        weekNumber: w.weekNumber,
        year: w.year,
        bucket,
        total,
        done,
        open: total - done,
        completionPct
      };
    });
  }, [weeks]);

  useEffect(() => {
    if(analyticsByWeek.length){
      setRangeFrom(0);
      setRangeTo(analyticsByWeek.length - 1);
    }
  }, [analyticsByWeek.length]);

  function computeTopCatsAcrossWeeks(rows, topN){
    const totals = {};
    rows.forEach(r => {
      Object.entries(r.bucket).forEach(([cat, v]) => {
        totals[cat] = (totals[cat] || 0) + (v.total || 0);
      });
    });
    return Object.entries(totals).sort((a,b)=>b[1]-a[1]).slice(0, topN).map(([k])=>k);
  }

  function stackValuesForWeek(row, topCats, mode){
    const baseTotal =
      mode === 'all' ? row.total :
      mode === 'done' ? row.done :
      row.open;

    if(!baseTotal) return { parts: topCats.map(()=>0).concat([0]) };

    let used = 0;
    const parts = topCats.map(cat => {
      const v = row.bucket[cat];
      let cnt = 0;
      if(v){
        cnt = mode === 'all' ? v.total : (mode === 'done' ? v.done : v.open);
      }
      used += cnt;
      return (cnt / baseTotal) * 100;
    });

    const othersCnt = Math.max(0, baseTotal - used);
    parts.push((othersCnt / baseTotal) * 100);
    return { parts };
  }

  const mainChartData = useMemo(() => {
    const top5 = computeTopCatsAcrossWeeks(analyticsByWeek, 5);
    const labels = analyticsByWeek.map(r => r.label);

    const barDatasets = [...top5, "Others"].map((cat, idx) => ({
      type: 'bar',
      label: cat,
      data: analyticsByWeek.map(r => {
        const { parts } = stackValuesForWeek(r, top5, stackMode);
        return parts[idx] ?? 0;
      }),
      yAxisID: 'y',
      stack: 'stack1'
    }));

    const lineDataset = {
      type: 'line',
      label: 'Completion %',
      data: analyticsByWeek.map(r => r.completionPct),
      yAxisID: 'y1',
      tension: 0.25,
      pointRadius: 3
    };

    return { labels, barDatasets, lineDataset };
  }, [analyticsByWeek, stackMode]);

  /* MINI: one stacked column for the selected range */
  const miniChartData = useMemo(() => {
    if(!analyticsByWeek.length) return null;

    const from = Math.min(rangeFrom, rangeTo);
    const to = Math.max(rangeFrom, rangeTo);
    const slice = analyticsByWeek.slice(from, to + 1);

    const top10 = computeTopCatsAcrossWeeks(slice, 10);

    const totals = {};
    let grand = 0;
    slice.forEach(r => {
      Object.entries(r.bucket).forEach(([cat, v]) => {
        totals[cat] = (totals[cat] || 0) + (v.total || 0);
        grand += (v.total || 0);
      });
    });

    const labels = [...top10, "Others"];
    let used = 0;
    const parts = top10.map(cat => {
      const v = totals[cat] || 0;
      used += v;
      return grand ? (v / grand) * 100 : 0;
    });
    const others = Math.max(0, grand - used);
    parts.push(grand ? (others / grand) * 100 : 0);

    // Build stacked datasets (each category is one dataset stacked into a single bar)
    const datasets = labels.map((lab, i) => ({
      label: lab,
      data: [parts[i] ?? 0],
      stack: 'miniStack'
    }));

    return { datasets };
  }, [analyticsByWeek, rangeFrom, rangeTo]);

  /* TABLE: show "done - total" for each category (Top10 + Others) */
  const analyticsTable = useMemo(() => {
    const top10 = computeTopCatsAcrossWeeks(analyticsByWeek, 10);
    const cols = [...top10, "Others"];

    const rows = analyticsByWeek.map(r => {
      const known = new Set(top10);
      let othersOpen = 0, othersDone = 0;

      const out = { week: r.label };

      cols.forEach(cat => {
        if(cat === "Others") return;
        const v = r.bucket[cat];
        const done = v ? v.done : 0;
        const open = v ? v.open : 0;
        const total = done + open;
        out[cat] = `${done} - ${total}`;
      });

      Object.entries(r.bucket).forEach(([cat, v]) => {
        if(known.has(cat)) return;
        othersOpen += v.open || 0;
        othersDone += v.done || 0;
      });

      out["Others"] = `${othersDone} - ${othersDone + othersOpen}`;
      return out;
    });

    return { cols, rows };
  }, [analyticsByWeek]);

  useEffect(() => {
    if(activeTab !== 'analytics') return;

    const ctx = mainChartRef.current;
    if(ctx){
      if(mainChartInstance.current){
        mainChartInstance.current.destroy();
        mainChartInstance.current = null;
      }
      mainChartInstance.current = new Chart(ctx, {
        data: {
          labels: mainChartData.labels,
          datasets: [...mainChartData.barDatasets, mainChartData.lineDataset]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { position: 'bottom' },
            linePointLabels: { datasetIndex: mainChartData.barDatasets.length }
          },
          scales: {
            y: {
              stacked: true,
              min: 0,
              max: 100,
              ticks: { callback: (v) => `${Math.round(v)}%` }
            },
            y1: {
              position: 'right',
              min: 0,
              max: 100,
              grid: { drawOnChartArea: false },
              ticks: { callback: (v) => `${Math.round(v)}%` }
            }
          }
        },
        plugins: [LinePointLabelPlugin]
      });
    }

    const ctx2 = miniChartRef.current;
    if(ctx2 && miniChartData){
      if(miniChartInstance.current){
        miniChartInstance.current.destroy();
        miniChartInstance.current = null;
      }
      miniChartInstance.current = new Chart(ctx2, {
        type: 'bar',
        data: {
          labels: ["Selected range"],
          datasets: miniChartData.datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { position: 'bottom' }
          },
          scales: {
            x: { stacked: true },
            y: { stacked: true, min: 0, max: 100, ticks: { callback: (v)=>`${Math.round(v)}%` } }
          }
        }
      });
    }
  }, [activeTab, mainChartData, miniChartData]);

  /* TODAY */
  const today = new Date();
  const todayKey = `${today.getFullYear()}-${today.getMonth()}-${today.getDate()}`;

  return (
    <div className="p-1 bg-white min-h-screen">
      <div className="bg-white w-full">

        {/* TOP BAR */}
        <div className="flex items-center gap-2 px-2 py-2 border-b border-gray-200">
          <button
            onClick={()=>setActiveTab('organizer')}
            className={`px-4 py-2 rounded-md text-sm font-medium transition ${
              activeTab==='organizer'
                ? 'bg-blue-600 text-white shadow'
                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
            }`}
          >
            Weekly Organizer
          </button>

          <button
            onClick={()=>setActiveTab('analytics')}
            className={`px-4 py-2 rounded-md text-sm font-medium transition ${
              activeTab==='analytics'
                ? 'bg-blue-600 text-white shadow'
                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
            }`}
          >
            Analytics
          </button>

          <div className="ml-auto flex gap-2">
            <button onClick={saveToFile} className="bg-green-600 hover:bg-green-700 text-white px-3 py-2 rounded">Save</button>
            <button onClick={()=>fileInputRef.current?.click()} className="bg-purple-600 hover:bg-purple-700 text-white px-3 py-2 rounded">Load</button>
            <input ref={fileInputRef} type="file" accept=".json" className="hidden" onChange={loadFromFile} />

           {activeTab==='organizer' && (
  <>
    <button
      onClick={()=>setShowAllWeeks(v=>!v)}
      className="bg-gray-200 hover:bg-gray-300 text-gray-800 px-3 py-2 rounded"
      title="Rendering all weeks slows typing. Keep this off for best performance."
    >
      {showAllWeeks ? 'Show latest week' : 'Show all weeks'}
    </button>
    <button onClick={addNewWeek} className="bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded">Add Week</button>
  </>
)}

          </div>
        </div>

        {/* ORGANIZER */}
        {activeTab === 'organizer' && (
          <div>
              {(showAllWeeks ? weeks : weeks.slice(0,4)).map((week)=>{

              const year = week.year || currentYear;
              const wkNum = Number(week.weekNumber) || currentWeek;
              const monday = getDateOfISOWeek(wkNum, year);
              const dates = [
                monday,
                new Date(monday.getFullYear(), monday.getMonth(), monday.getDate()+1),
                new Date(monday.getFullYear(), monday.getMonth(), monday.getDate()+2),
                new Date(monday.getFullYear(), monday.getMonth(), monday.getDate()+3),
                new Date(monday.getFullYear(), monday.getMonth(), monday.getDate()+4)
              ];

              let todayColIndex = -1;
              dates.forEach((d,i)=>{
                const key = `${d.getFullYear()}-${d.getMonth()}-${d.getDate()}`;
                if(key === todayKey) todayColIndex = i + 2;
              });

              return (
                <table key={week.id} className="w-full border-collapse mb-2">
                  <thead>
                    <tr>
                      <th
                        className="text-white text-center px-2 py-1 text-xs"
                        style={{ background:'#374151', whiteSpace:'nowrap', width:'160px' }}
                      >
                        W-
                        <input
                          value={week.weekNumber}
                          onChange={(e)=> updateWeekNumber(week.id, parseInt(e.target.value) || 0)}
                          className="w-10 text-xs font-semibold bg-transparent border-b border-gray-300 focus:outline-none text-white text-center"
                        />
                        {" "} / Deleg.
                      </th>

                      <th className="text-white text-center px-2 py-1 text-xs" style={{ background:'#374151', whiteSpace:'nowrap' }}>
                        Weekly Objectives
                      </th>

                      {["Monday","Tuesday","Wednesday","Thursday","Friday"].map((day,i)=>{
                        const idx = i + 2;
                        const isToday = idx === todayColIndex;
                        return (
                          <th
                            key={day}
                            className="text-white text-center px-2 py-1 text-xs"
                            style={{
                              background: isToday ? '#3b82f6' : '#374151',
                              borderLeft: isToday ? '3px solid #2563eb' : '0',
                              borderRight: isToday ? '3px solid #2563eb' : '0',
                              whiteSpace:'nowrap'
                            }}
                          >
                            {day} ({formatDayShort(dates[i])})
                          </th>
                        );
                      })}
                    </tr>
                  </thead>

                  <tbody>
                    {week.tasks.map((row,rowIndex)=>(
                      <tr key={rowIndex}>
                        {columns.map((col, colIndex)=>{
                          const cellRaw = row[col];
                          const style = getCellStyle(col, rowIndex, cellRaw.text);
                          const isToday = colIndex === todayColIndex;

                          const leftBorder = colIndex === 0 ? '0' : '1px solid rgba(0,0,0,0.06)';
                          const cellBorderLeft = isToday ? '3px solid #2563eb' : leftBorder;
                          const cellBorderRight = isToday ? '3px solid #2563eb' : '0';

                          const lines = (cellRaw.text || "").split("\n");
                          const cell = ensureSubtasksLength(cellRaw, lines.length);

                          const mainBg =
                            cell.status === 0 ? "#fff" :
                            cell.status === 1 ? "#f97316" :
                            "#22c55e";

                          const mainTextColor =
                            cell.status === 2 ? "#fff" : "#111827";

                          return (
                            <td
                              key={col}
                              onDragOver={(e) => { e.preventDefault(); setDragOverCell({ weekId: week.id, rowIndex, col }); }}
                              onDragLeave={() => setDragOverCell(null)}
                              onDrop={(e) => { handleDrop(e, week.id, rowIndex, col); setDragOverCell(null); }}
                              style={{
                                backgroundColor: style.bg,
                                borderLeft: cellBorderLeft,
                                borderRight: cellBorderRight,
                                verticalAlign:'top',
                                padding:'2px',
                                width: col === "delegatedTasks" ? "160px" : "auto",
                                outline: dragOverCell &&
                                  dragOverCell.weekId === week.id &&
                                  dragOverCell.rowIndex === rowIndex &&
                                  dragOverCell.col === col
                                  ? "2px dashed #2563eb"
                                  : "none",
                                outlineOffset: -2
                              }}
                            >
                              <div style={{ display:'flex', alignItems:'flex-start', gap:6 }}>

                                {/* LEFT: grid aligned with textarea lines */}
                                <div
                                  style={{
                                    width: 18,
                                    display: 'grid',
                                    gridAutoRows: '1.2rem',   /* exact textarea line-height */
                                    alignItems: 'center',
                                    justifyItems: 'center',
                                    opacity: style.ghost ? 0.45 : 1
                                  }}
                                >
                                  {/* row 0: main button */}
                                  <div
                                    draggable
                                    onDragStart={()=>setDraggedItem({ weekId:week.id, rowIndex, col })}
                                    onClick={() => toggleMainStatus(week.id, rowIndex, col)}
                                    title="Click: status 0→1→2"
                                    style={{
                                      width: 16,
                                      height: 16,
                                      borderRadius: 3,
                                      border: "1px solid #cbd5e1",
                                      background: mainBg,
                                      color: mainTextColor,
                                      cursor: 'pointer',
                                      display:'flex',
                                      alignItems:'center',
                                      justifyContent:'center',
                                      fontSize: 9,
                                      fontWeight: 700,
                                      lineHeight: '16px',
                                      userSelect: 'none'
                                    }}
                                  >
                                    {cell.ranking}
                                  </div>

                                  {/* rows 1..n: small buttons aligned to each extra line */}
                                  {Array.from({length: Math.max(0, lines.length - 1)}).map((_, si) => {
                                    const st = cell.subtasks?.[si]?.status ?? 0;
                                    const bg = st === 0 ? "#fff" : st === 1 ? "#f97316" : "#22c55e";
                                    const fg = st === 2 ? "#fff" : "#111827";
                                    return (
                                      <div
                                        key={si}
                                        onClick={() => toggleSubStatus(week.id, rowIndex, col, si)}
                                        title="Subtask status 0→1→2"
                                        style={{
                                          width: 12,
                                          height: 12,
                                          borderRadius: 3,
                                          border: "1px solid #cbd5e1",
                                          background: bg,
                                          color: fg,
                                          cursor:'pointer'
                                        }}
                                      />
                                    );
                                  })}
                                </div>

                                {/* RIGHT: textarea */}
                                <div style={{ flex:1 }}>
                                  <textarea
                                    value={cell.text}
                                    onChange={(e)=>updateTask(week.id,rowIndex,col,'text',e.target.value)}
                                    onKeyDown={(e)=>handleKeyDown(e, week.id, rowIndex, colIndex)}
                                    onBlur={(e)=>onCellBlur(week.id, rowIndex, col, e.target.value)}
                                    ref={el=>{ inputRefs.current[`${week.id}-${rowIndex}-${colIndex}`]=el; }}
                                    placeholder={style.ghost ? "..." : "Task..."}
                                    style={{
                                      width:'100%',
                                      minHeight:20,
                                      resize:'none',
                                      overflow:'hidden',
                                      background:'transparent',
                                      color: cell.status === 2
                                        ? (style.bg.includes("#dc2626") || style.bg.includes("#f97316") ? "#fff" : "#6b7280")
                                        : style.text,
                                      textDecoration: cell.status === 2 ? "line-through" : "none",
                                      border:'none',
                                      outline:'none',
                                      fontSize:12,
                                      lineHeight:'1.2rem',
                                      fontStyle: style.ghost ? 'italic' : 'normal'
                                    }}
                                    onInput={(e)=>{
                                      e.target.style.height='auto';
                                      e.target.style.height=e.target.scrollHeight+'px';
                                    }}
                                  />
                                </div>

                              </div>
                            </td>
                          );
                        })}
                      </tr>
                    ))}
                  </tbody>
                </table>
              );
            })}
          </div>
        )}

        {/* ANALYTICS */}
        {activeTab === 'analytics' && (
          <div className="p-3">
            <div className="flex flex-wrap items-center gap-2 mb-3">
              <div className="text-sm text-gray-700 font-medium">Stacked bars mode:</div>
              <button onClick={()=>setStackMode('all')}
                className={`px-3 py-1 rounded text-sm ${stackMode==='all' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>
                All entries
              </button>
              <button onClick={()=>setStackMode('done')}
                className={`px-3 py-1 rounded text-sm ${stackMode==='done' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>
                Completed only
              </button>
              <button onClick={()=>setStackMode('open')}
                className={`px-3 py-1 rounded text-sm ${stackMode==='open' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>
                Uncompleted only
              </button>

              <div className="ml-auto text-xs text-gray-500">
                Analytics includes <b>Monday–Friday</b> only.
              </div>
            </div>

            <div className="grid grid-cols-1 lg:grid-cols-3 gap-3">
              <div className="bg-white border border-gray-200 rounded p-3 lg:col-span-2">
                <div className="text-sm font-semibold mb-2">Weekly trends</div>
                <div style={{ height: 320 }}>
                  <canvas ref={mainChartRef}></canvas>
                </div>
              </div>

              <div className="bg-white border border-gray-200 rounded p-3">
                <div className="text-sm font-semibold mb-2">Top categories (range)</div>

                <div className="flex flex-col gap-2 mb-2">
                  <div className="text-xs text-gray-600">
                    Weeks range: <b>{analyticsByWeek[Math.min(rangeFrom, rangeTo)]?.label || '-'}</b> → <b>{analyticsByWeek[Math.max(rangeFrom, rangeTo)]?.label || '-'}</b>
                  </div>
                  <input type="range" min="0" max={Math.max(0, analyticsByWeek.length-1)} value={rangeFrom}
                    onChange={(e)=>setRangeFrom(parseInt(e.target.value,10))} />
                  <input type="range" min="0" max={Math.max(0, analyticsByWeek.length-1)} value={rangeTo}
                    onChange={(e)=>setRangeTo(parseInt(e.target.value,10))} />
                </div>

                <div style={{ height: 260 }}>
                  <canvas ref={miniChartRef}></canvas>
                </div>

                <div className="text-xs text-gray-500 mt-2">
                  Single stacked bar (Top 10 + Others) for selected weeks.
                </div>
              </div>
            </div>

            <div className="bg-white border border-gray-200 rounded p-3 mt-3 overflow-x-auto">
              <div className="text-sm font-semibold mb-2">Weekly table (Top 10 + Others) — “done - total”</div>

              <table className="w-full" style={{ borderCollapse:'collapse' }}>
                <thead>
                  <tr className="bg-gray-700 text-white text-xs">
                    <th className="p-2 text-left" style={{ position:'sticky', left:0, background:'#374151' }}>Week</th>
                    {analyticsTable.cols.map(cat => (
                      <th key={cat} className="p-2 text-center">{cat}</th>
                    ))}
                  </tr>
                </thead>
                <tbody>
                  {analyticsTable.rows.map((r, idx) => (
                    <tr key={idx} className="border-b border-gray-200 text-xs">
                      <td className="p-2 font-semibold" style={{ position:'sticky', left:0, background:'#fff' }}>
                        {r.week}
                      </td>
                      {analyticsTable.cols.map(cat => (
                        <td key={cat} className="p-2 text-center">{r[cat]}</td>
                      ))}
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>

          </div>
        )}

      </div>
    </div>
  );
}

/* ---------- boot ---------- */
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<WeeklyTaskOrganizer />);
</script>
</body>
</html>

