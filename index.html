<div>Hello, test!</div>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weekly Task Organizer</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use the React UMD build for Lucide icons -->
    <script src="https://unpkg.com/lucide-react@latest/umd/lucide-react.production.min.js"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
      const { useState, useRef } = React;
      const { Plus, Trash2, Save, Upload, GripVertical } = lucideReact;

      const WeeklyTaskOrganizer = () => {
        const [weeks, setWeeks] = useState([{
          id: Date.now(),
          tasks: Array(16).fill(null).map((_, i) => ({
            delegatedTasks: { text: '', completed: false, ranking: i + 1 },
            weeklyObjectives: { text: '', completed: false, ranking: i + 1 },
            monday: { text: '', completed: false, ranking: i + 1 },
            tuesday: { text: '', completed: false, ranking: i + 1 },
            wednesday: { text: '', completed: false, ranking: i + 1 },
            thursday: { text: '', completed: false, ranking: i + 1 },
            friday: { text: '', completed: false, ranking: i + 1 }
          }))
        }]);

        const [draggedItem, setDraggedItem] = useState(null);
        const inputRefs = useRef({});
        const fileInputRef = useRef(null);

        const columns = ['delegatedTasks', 'weeklyObjectives', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday'];
        const columnLabels = ['Delegated Tasks', 'Weekly Objectives', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];

        const getWeeklyObjectivesColor = (rowIndex) => {
          if (rowIndex >= 0 && rowIndex <= 3) return { bg: 'bg-red-600', text: 'text-white', input: 'bg-red-500 text-white placeholder-red-200' };
          if (rowIndex >= 4 && rowIndex <= 7) return { bg: 'bg-orange-500', text: 'text-white', input: 'bg-orange-400 text-white placeholder-orange-200' };
          if (rowIndex >= 8 && rowIndex <= 11) return { bg: 'bg-yellow-400', text: 'text-black', input: 'bg-yellow-300 text-black placeholder-yellow-600' };
          if (rowIndex >= 12 && rowIndex <= 15) return { bg: 'bg-yellow-200', text: 'text-black', input: 'bg-yellow-100 text-black placeholder-yellow-500' };
          return { bg: 'bg-white', text: 'text-black', input: 'bg-white text-black' };
        };

        const getDayColumnColor = (rowIndex) => {
          if (rowIndex === 0) return { bg: 'bg-red-600', text: 'text-white', input: 'bg-red-500 text-white placeholder-red-200' };
          if (rowIndex >= 1 && rowIndex <= 3) return { bg: 'bg-yellow-300', text: 'text-black', input: 'bg-yellow-200 text-black placeholder-yellow-600' };
          if (rowIndex >= 14) return { bg: 'bg-blue-50', text: 'text-black', input: 'bg-blue-100 text-black placeholder-blue-400' };
          return { bg: 'bg-white', text: 'text-black', input: 'bg-white text-black' };
        };

        const getCellStyle = (column, rowIndex) => {
          if (column === 'weeklyObjectives') {
            return getWeeklyObjectivesColor(rowIndex);
          }
          if (column === 'delegatedTasks') {
            return { bg: 'bg-white', text: 'text-black', input: 'bg-white text-black' };
          }
          return getDayColumnColor(rowIndex);
        };

        const getCategoryRange = (column, rowIndex) => {
          if (column === 'weeklyObjectives') {
            if (rowIndex >= 0 && rowIndex <= 3) return [0, 3];
            if (rowIndex >= 4 && rowIndex <= 7) return [4, 7];
            if (rowIndex >= 8 && rowIndex <= 11) return [8, 11];
            if (rowIndex >= 12 && rowIndex <= 15) return [12, 15];
          } else if (column === 'delegatedTasks') {
            return [0, 15];
          } else {
            if (rowIndex === 0) return [0, 0];
            if (rowIndex >= 1 && rowIndex <= 3) return [1, 3];
            if (rowIndex >= 4 && rowIndex <= 13) return [4, 13];
            if (rowIndex >= 14 && rowIndex <= 15) return [14, 15];
          }
          return [0, 15];
        };

        const sortColumnByCategory = (tasks, column) => {
          const newTasks = [...tasks];
          const categories = [
            column === 'weeklyObjectives' ? [0, 3] : column === 'delegatedTasks' ? [0, 15] : [0, 0],
            column === 'weeklyObjectives' ? [4, 7] : column === 'delegatedTasks' ? null : [1, 3],
            column === 'weeklyObjectives' ? [8, 11] : column === 'delegatedTasks' ? null : [4, 13],
            column === 'weeklyObjectives' ? [12, 15] : column === 'delegatedTasks' ? null : [14, 15]
          ].filter(cat => cat !== null);

          categories.forEach(([start, end]) => {
            const categoryTasks = [];
            for (let i = start; i <= end; i++) {
              categoryTasks.push({ task: newTasks[i][column], index: i });
            }

            const incomplete = categoryTasks.filter(t => !t.task.completed);
            const completed = categoryTasks.filter(t => t.task.completed);

            incomplete.sort((a, b) => a.task.ranking - b.task.ranking);

            const sorted = [...incomplete, ...completed];

            sorted.forEach((item, idx) => {
              newTasks[start + idx] = {
                ...newTasks[start + idx],
                [column]: item.task
              };
            });
          });

          return newTasks;
        };

        const updateTask = (weekId, rowIndex, column, field, value) => {
          setWeeks(prevWeeks => prevWeeks.map(week => {
            if (week.id !== weekId) return week;

            let newTasks = [...week.tasks];

            if (field === 'ranking') {
              const numValue = parseInt(value) || 1;
              const [catStart, catEnd] = getCategoryRange(column, rowIndex);

              const otherTaskIndex = newTasks.findIndex((t, i) =>
                i >= catStart && i <= catEnd && i !== rowIndex && t[column].ranking === numValue
              );

              if (otherTaskIndex !== -1) {
                newTasks[otherTaskIndex] = {
                  ...newTasks[otherTaskIndex],
                  [column]: { ...newTasks[otherTaskIndex][column], ranking: newTasks[rowIndex][column].ranking }
                };
              }

              newTasks[rowIndex] = {
                ...newTasks[rowIndex],
                [column]: { ...newTasks[rowIndex][column], [field]: numValue }
              };
            } else {
              newTasks[rowIndex] = {
                ...newTasks[rowIndex],
                [column]: { ...newTasks[rowIndex][column], [field]: value }
              };
            }

            newTasks = sortColumnByCategory(newTasks, column);

            return { ...week, tasks: newTasks };
          }));
        };

        const handleDragStart = (e, weekId, rowIndex, column) => {
          setDraggedItem({ weekId, rowIndex, column });
          e.dataTransfer.effectAllowed = 'move';
        };

        const handleDragOver = (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
        };

        const handleDrop = (e, weekId, targetRowIndex, targetColumn) => {
          e.preventDefault();

          if (!draggedItem || draggedItem.weekId !== weekId || draggedItem.column !== targetColumn) {
            setDraggedItem(null);
            return;
          }

          const [sourceCatStart, sourceCatEnd] = getCategoryRange(targetColumn, draggedItem.rowIndex);
          const [targetCatStart, targetCatEnd] = getCategoryRange(targetColumn, targetRowIndex);

          if (sourceCatStart !== targetCatStart || sourceCatEnd !== targetCatEnd) {
            setDraggedItem(null);
            return;
          }

          setWeeks(prevWeeks => prevWeeks.map(week => {
            if (week.id !== weekId) return week;

            const newTasks = [...week.tasks];
            const sourceIndex = draggedItem.rowIndex;
            const targetIndex = targetRowIndex;

            const sourceTask = newTasks[sourceIndex][targetColumn];
            const targetTask = newTasks[targetIndex][targetColumn];

            const newSourceRanking = targetIndex + 1;
            const newTargetRanking = sourceIndex + 1;

            newTasks[sourceIndex] = {
              ...newTasks[sourceIndex],
              [targetColumn]: { ...targetTask, ranking: newTargetRanking }
            };

            newTasks[targetIndex] = {
              ...newTasks[targetIndex],
              [targetColumn]: { ...sourceTask, ranking: newSourceRanking }
            };

            return { ...week, tasks: newTasks };
          }));

          setDraggedItem(null);
        };

        const handleKeyDown = (e, weekId, rowIndex, colIndex) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            const nextRow = rowIndex + 1;
            if (nextRow < 16) {
              const ref = inputRefs.current[`${weekId}-${nextRow}-${colIndex}`];
              if (ref) ref.focus();
            }
          } else if (e.key === 'Tab' && !e.shiftKey) {
            e.preventDefault();
            const nextCol = colIndex + 1;
            if (nextCol < columns.length) {
              const ref = inputRefs.current[`${weekId}-${rowIndex}-${nextCol}`];
              if (ref) ref.focus();
            } else {
              const nextRow = rowIndex + 1;
              if (nextRow < 16) {
                const ref = inputRefs.current[`${weekId}-${nextRow}-0`];
                if (ref) ref.focus();
              }
            }
          } else if (e.key === 'Tab' && e.shiftKey) {
            e.preventDefault();
            const prevCol = colIndex - 1;
            if (prevCol >= 0) {
              const ref = inputRefs.current[`${weekId}-${rowIndex}-${prevCol}`];
              if (ref) ref.focus();
            } else {
              const prevRow = rowIndex - 1;
              if (prevRow >= 0) {
                const ref = inputRefs.current[`${weekId}-${prevRow}-${columns.length - 1}`];
                if (ref) ref.focus();
              }
            }
          }
        };

        const addNewWeek = () => {
          const lastWeek = weeks[0];
          const newWeekTasks = Array(16).fill(null).map((_, i) => ({
            delegatedTasks: { text: '', completed: false, ranking: i + 1 },
            weeklyObjectives: { text: '', completed: false, ranking: i + 1 },
            monday: { text: '', completed: false, ranking: i + 1 },
            tuesday: { text: '', completed: false, ranking: i + 1 },
            wednesday: { text: '', completed: false, ranking: i + 1 },
            thursday: { text: '', completed: false, ranking: i + 1 },
            friday: { text: '', completed: false, ranking: i + 1 }
          }));

          const openWeeklyObjectives = lastWeek.tasks.filter(t =>
            !t.weeklyObjectives.completed && t.weeklyObjectives.text.trim()
          );
          const openDelegatedTasks = lastWeek.tasks.filter(t =>
            !t.delegatedTasks.completed && t.delegatedTasks.text.trim()
          );

          openWeeklyObjectives.forEach((task, idx) => {
            if (idx < 16) {
              newWeekTasks[idx].weeklyObjectives = {
                text: task.weeklyObjectives.text,
                completed: false,
                ranking: task.weeklyObjectives.ranking
              };
            }
          });

          openDelegatedTasks.forEach((task, idx) => {
            if (idx < 16) {
              newWeekTasks[idx].delegatedTasks = {
                text: task.delegatedTasks.text,
                completed: false,
                ranking: task.delegatedTasks.ranking
              };
            }
          });

          setWeeks([{ id: Date.now(), tasks: newWeekTasks }, ...weeks]);
        };

        const deleteWeek = (weekId) => {
          if (weeks.length > 1) {
            setWeeks(weeks.filter(w => w.id !== weekId));
          }
        };

        const saveToFile = () => {
          const dataStr = JSON.stringify(weeks, null, 2);
          const dataBlob = new Blob([dataStr], { type: 'application/json' });
          const url = URL.createObjectURL(dataBlob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `task-organizer-${new Date().toISOString().split('T')[0]}.json`;
          link.click();
          URL.revokeObjectURL(url);
        };

        const loadFromFile = (event) => {
          const file = event.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const loadedData = JSON.parse(e.target.result);
                setWeeks(loadedData);
              } catch (error) {
                alert('Error loading file. Please make sure it is a valid task organizer file.');
              }
            };
            reader.readAsText(file);
          }
        };

        return React.createElement('div', { className: 'min-h-screen bg-gray-100 p-4' },
          React.createElement('div', { className: 'max-w-[1800px] mx-auto' },
            React.createElement('div', { className: 'flex justify-between items-center mb-6' },
              React.createElement('h1', { className: 'text-3xl font-bold text-gray-800' }, 'Weekly Task Organizer'),
              React.createElement('div', { className: 'flex gap-3' },
                React.createElement('button', {
                  onClick: saveToFile,
                  className: 'flex items-center gap-2 bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg transition-colors'
                },
                  React.createElement(Save, { size: 20 }),
                  ' Save Project'
                ),
                React.createElement('button', {
                  onClick: () => fileInputRef.current?.click(),
                  className: 'flex items-center gap-2 bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-lg transition-colors'
                },
                  React.createElement(Upload, { size: 20 }),
                  ' Load Project'
                ),
                React.createElement('input', {
                  ref: fileInputRef,
                  type: 'file',
                  accept: '.json',
                  onChange: loadFromFile,
                  className: 'hidden'
                }),
                React.createElement('button', {
                  onClick: addNewWeek,
                  className: 'flex items-center gap-2 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg transition-colors'
                },
                  React.createElement(Plus, { size: 20 }),
                  ' Add New Week'
                )
              )
            ),
            weeks.map((week, weekIndex) =>
              React.createElement('div', { key: week.id, className: 'mb-8 bg-white rounded-lg shadow-lg p-6' },
                React.createElement('div', { className: 'flex justify-between items-center mb-4' },
                  React.createElement('h2', { className: 'text-xl font-semibold text-gray-700' }, `Week ${weeks.length - weekIndex}`),
                  weeks.length > 1 && React.createElement('button', {
                    onClick: () => deleteWeek(week.id),
                    className: 'flex items-center gap-2 bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded transition-colors text-sm'
                  },
                    React.createElement(Trash2, { size: 16 }),
                    ' Delete Week'
                  )
                ),
                React.createElement('div', { className: 'overflow-x-auto' },
                  React.createElement('table', { className: 'w-full border-collapse table-fixed' },
                    React.createElement('thead', null,
                      React.createElement('tr', null,
                        columnLabels.map(label =>
                          React.createElement('th', {
                            key: label,
                            className: 'border border-gray-300 p-2 bg-gray-700 text-white text-sm w-[14.28%]'
                          }, label)
                        )
                      )
                    ),
                    React.createElement('tbody', null,
                      week.tasks.map((task, rowIndex) =>
                        React.createElement('tr', { key: rowIndex },
                          columns.map((col, colIndex) => {
                            const styles = getCellStyle(col, rowIndex);
                            return React.createElement('td', {
                              key: col,
                              className: `border border-gray-300 p-1 ${styles.bg}`,
                              draggable: true,
                              onDragStart: (e) => handleDragStart(e, week.id, rowIndex, col),
                              onDragOver: handleDragOver,
                              onDrop: (e) => handleDrop(e, week.id, rowIndex, col)
                            },
                              React.createElement('div', { className: 'flex items-start gap-1' },
                                React.createElement(GripVertical, {
                                  size: 14,
                                  className: `${styles.text} cursor-move flex-shrink-0 mt-0.5`
                                }),
                                React.createElement('input', {
                                  type: 'checkbox',
                                  checked: task[col].completed,
                                  onChange: (e) => updateTask(week.id, rowIndex, col, 'completed', e.target.checked),
                                  className: 'w-3.5 h-3.5 cursor-pointer flex-shrink-0 mt-0.5'
                                }),
                                React.createElement('input', {
                                  type: 'number',
                                  min: '1',
                                  value: task[col].ranking,
                                  onChange: (e) => updateTask(week.id, rowIndex, col, 'ranking', e.target.value),
                                  className: `w-8 px-0.5 py-0.5 text-xs text-center flex-shrink-0 border-0 outline-none ${styles.input}`,
                                  style: { MozAppearance: 'textfield', WebkitAppearance: 'none', appearance: 'none' }
                                }),
                                React.createElement('textarea', {
                                  value: task[col].text,
                                  onChange: (e) => updateTask(week.id, rowIndex, col, 'text', e.target.value),
                                  onKeyDown: (e) => handleKeyDown(e, week.id, rowIndex, colIndex),
                                  ref: (el) => inputRefs.current[`${week.id}-${rowIndex}-${colIndex}`] = el,
                                  className: `flex-1 px-1 py-0.5 text-xs border-0 outline-none resize-none overflow-hidden ${styles.input}`,
                                  placeholder: 'Task...',
                                  rows: '1',
                                  style: { minHeight: '20px' },
                                  onInput: (e) => {
                                    e.target.style.height = 'auto';
                                    e.target.style.height = e.target.scrollHeight + 'px';
                                  }
                                })
                              )
                            );
                          })
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(React.createElement(WeeklyTaskOrganizer));
    </script>
</body>
</html>
