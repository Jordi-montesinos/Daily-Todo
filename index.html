<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Weekly Task Organizer</title>

  <!-- React + Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Lucide -->
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
</head>
<body class="bg-gray-100 min-h-screen">
  <div id="root"></div>

  <script type="text/babel">
  const { useState, useEffect, useRef } = React;

  // --- Utility: ISO week helpers ---
  function getISOWeekAndYear(date) {
    // returns [weekNumber, year]
    const tmp = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    // Thursday in current week decides the year.
    tmp.setUTCDate(tmp.getUTCDate() + 4 - (tmp.getUTCDay() || 7));
    const yearStart = new Date(Date.UTC(tmp.getUTCFullYear(),0,1));
    const weekNo = Math.ceil((((tmp - yearStart) / 86400000) + 1)/7);
    return [weekNo, tmp.getUTCFullYear()];
  }

  function getDateOfISOWeek(week, year) {
    // Returns Date object for Monday of ISO week in given year
    const jan4 = new Date(Date.UTC(year, 0, 4));
    const jan4Day = jan4.getUTCDay() || 7; // 1..7
    const monday = new Date(jan4);
    monday.setUTCDate(jan4.getUTCDate() - (jan4Day - 1) + (week - 1) * 7);
    return new Date(monday.getUTCFullYear(), monday.getUTCMonth(), monday.getUTCDate()); // local date object
  }

  function formatDayShort(d) {
    const dd = String(d.getDate()).padStart(2,'0');
    const monthNames = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
    return dd + '/' + monthNames[d.getMonth()];
  }

  // --- Defaults & helpers for tasks/weeks ---
  function makeEmptyTasks() {
    return Array(16).fill(null).map((_, i) => ({
      delegatedTasks: { text: "", completed: false, ranking: i+1 },
      weeklyObjectives: { text: "", completed: false, ranking: i+1 },
      monday: { text: "", completed: false, ranking: i+1 },
      tuesday: { text: "", completed: false, ranking: i+1 },
      wednesday: { text: "", completed: false, ranking: i+1 },
      thursday: { text: "", completed: false, ranking: i+1 },
      friday: { text: "", completed: false, ranking: i+1 }
    }));
  }

  // compute current ISO week/year
  const [currentWeek, currentYear] = getISOWeekAndYear(new Date());

  // --- Component ---
  function WeeklyTaskOrganizer() {
    const initial = () => {
      const saved = localStorage.getItem('weekly-task-organizer');
      if (saved) {
        try { return JSON.parse(saved); } catch { /* ignore */ }
      }
      // default single week with current ISO week / year
      return [{
        id: Date.now(),
        weekNumber: currentWeek,
        year: currentYear,
        tasks: makeEmptyTasks()
      }];
    };

    const [weeks, setWeeks] = useState(initial);
    const [draggedItem, setDraggedItem] = useState(null);
    const inputRefs = useRef({});
    const fileInputRef = useRef(null);
    const rowRefs = useRef({}); // keyed by weekId -> array of rows -> array of cells

    const columns = ["delegatedTasks","weeklyObjectives","monday","tuesday","wednesday","thursday","friday"];
    const columnLabels = ["Delegated Tasks","Weekly Objectives","Monday","Tuesday","Wednesday","Thursday","Friday"];

    // colors (exact hex to use for background)
    function getWeeklyObjectivesColor(i){
      if(i<=3) return { bg:"#dc2626", text:"white" };        // red
      if(i<=7) return { bg:"#f97316", text:"white" };       // orange
      if(i<=11) return { bg:"#facc15", text:"black" };     // yellow
      return { bg:"#fde68a", text:"black" };                // light yellow
    }
    function getDayColumnColor(i){
      if(i===0) return { bg:"#dc2626", text:"white" };
      if(i<=3) return { bg:"#fcd34d", text:"black" };
      if(i>=14) return { bg:"#eff6ff", text:"black" };
      return { bg:"#ffffff", text:"black" };
    }
    function getCellStyle(col, rowIndex){
      if(col === 'weeklyObjectives') return getWeeklyObjectivesColor(rowIndex);
      if(col === 'delegatedTasks') return { bg:"#ffffff", text:"black" };
      return getDayColumnColor(rowIndex);
    }

    // category ranges for weeklyObjectives & days
    function getCategoryRange(col, rowIndex){
      if(col === 'weeklyObjectives'){
        if(rowIndex <= 3) return [0,3];
        if(rowIndex <= 7) return [4,7];
        if(rowIndex <= 11) return [8,11];
        return [12,15];
      }
      if(col === 'delegatedTasks') return [0,15];
      if(rowIndex === 0) return [0,0];
      if(rowIndex <= 3) return [1,3];
      if(rowIndex <= 13) return [4,13];
      return [14,15];
    }

    // sorts a column inside its category segments: incomplete first by ranking, then completed by ranking
    function sortColumnByCategory(tasks, col){
      const newTasks = [...tasks];
      const ranges = [
        getCategoryRange(col, 0)[0] === 0 ? getCategoryRange(col,0) : [0,3],
        [4,7],
        [8,11],
        [12,15]
      ];
      ranges.forEach(([start,end])=>{
        const seg = [];
        for(let i=start;i<=end;i++) seg.push({task:newTasks[i][col]});
        const incomplete = seg.filter(i=>!i.task.completed).sort((a,b)=>a.task.ranking-b.task.ranking);
        const complete = seg.filter(i=>i.task.completed).sort((a,b)=>a.task.ranking-b.task.ranking);
        const merged = [...incomplete,...complete];
        merged.forEach((it, idx) => {
          newTasks[start + idx] = { ...newTasks[start + idx], [col]: it.task };
        });
      });
      return newTasks;
    }

    // updateTask: update field and then sort the column categories
    function updateTask(weekId, rowIndex, col, field, value){
      setWeeks(prev => prev.map(w=>{
        if(w.id !== weekId) return w;
        let newTasks = [...w.tasks];
        newTasks[rowIndex] = { ...newTasks[rowIndex], [col]: { ...newTasks[rowIndex][col], [field]: value } };
        newTasks = sortColumnByCategory(newTasks, col);
        return { ...w, tasks: newTasks };
      }));
    }

    // drag & drop handlers
    function handleDragStart(e, weekId, rowIndex, col){
      setDraggedItem({ weekId, rowIndex, col });
      e.dataTransfer.effectAllowed = 'move';
    }
    function handleDrop(e, weekId, targetRow, col){
      e.preventDefault();
      if(!draggedItem || draggedItem.weekId !== weekId || draggedItem.col !== col){
        setDraggedItem(null);
        return;
      }
      setWeeks(prev => prev.map(w=>{
        if(w.id !== weekId) return w;
        const tasks = [...w.tasks];
        // swap
        const tmp = tasks[draggedItem.rowIndex][col];
        tasks[draggedItem.rowIndex][col] = tasks[targetRow][col];
        tasks[targetRow][col] = tmp;
        return { ...w, tasks: sortColumnByCategory(tasks, col) };
      }));
      setDraggedItem(null);
    }

    // keyboard navigation
    function focusCell(weekId, row, col){
      if(row < 0 || col < 0 || col >= columns.length || row >= 16) return;
      const key = `${weekId}-${row}-${col}`;
      const el = inputRefs.current[key];
      if(el) el.focus();
    }
    function handleKeyDown(e, weekId, row, col){
      if(e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); focusCell(weekId, row+1, col); }
      else if(e.key === 'Enter' && e.shiftKey){ e.preventDefault(); focusCell(weekId, row-1, col); }
      else if(e.key === 'Tab' && !e.shiftKey){ e.preventDefault(); focusCell(weekId, row, col+1); }
      else if(e.key === 'Tab' && e.shiftKey){ e.preventDefault(); focusCell(weekId, row, col-1); }
    }

    // add/delete weeks
    function addNewWeek(){
      const prev = weeks[0];
      const nowYear = new Date().getFullYear();
      const nextNumber = prev && typeof prev.weekNumber === 'number' ? prev.weekNumber + 1 : currentWeek;
      const newWeek = {
        id: Date.now(),
        weekNumber: nextNumber,
        year: nowYear, // per your request: use current year at creation
        tasks: makeEmptyTasks()
      };
      // carry over open tasks (first two columns)
      if(prev){
        const openDel = prev.tasks.filter(t => t.delegatedTasks.text.trim() && !t.delegatedTasks.completed);
        const openObj = prev.tasks.filter(t => t.weeklyObjectives.text.trim() && !t.weeklyObjectives.completed);
        openDel.forEach((t, idx) => { if(idx < 16) newWeek.tasks[idx].delegatedTasks = { ...t.delegatedTasks, completed:false }; });
        openObj.forEach((t, idx) => { if(idx < 16) newWeek.tasks[idx].weeklyObjectives = { ...t.weeklyObjectives, completed:false }; });
      }
      setWeeks([newWeek, ...weeks]);
    }
    function deleteWeek(id){
      if(weeks.length <= 1) return;
      setWeeks(weeks.filter(w => w.id !== id));
    }

    // save/load
    function saveToFile(){
      const blob = new Blob([JSON.stringify(weeks, null, 2)], { type:'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `weekly-organizer-${new Date().toISOString().split('T')[0]}.json`;
      a.click();
      URL.revokeObjectURL(a.href);
    }
    function loadFromFile(e){
      const f = e.target.files?.[0];
      if(!f) return;
      const r = new FileReader();
      r.onload = ev => {
        try {
          const data = JSON.parse(ev.target.result);
          setWeeks(data);
        } catch {
          alert('Invalid file');
        }
      };
      r.readAsText(f);
    }

    // week number edit (in header)
    function updateWeekNumber(weekId, newNumber){
      setWeeks(prev => prev.map(w => w.id === weekId ? { ...w, weekNumber: newNumber } : w ));
    }

    // autosave to localStorage
    useEffect(()=> {
      try { localStorage.setItem('weekly-task-organizer', JSON.stringify(weeks)); } catch {}
    }, [weeks]);

    // lucide icons render
    useEffect(()=> lucide.createIcons());

    // auto-resize rows per-week
    useEffect(()=>{
      // for each week id, compute per-row max height across its cells
      weeks.forEach(wk => {
        const id = wk.id;
        const byRow = rowRefs.current[id];
        if(!byRow) return;
        byRow.forEach((cells, rowIndex) => {
          if(!cells) return;
          let max = 0;
          cells.forEach(cell => { if(cell) max = Math.max(max, cell.scrollHeight); });
          cells.forEach(cell => { if(cell) cell.style.height = (max || 20) + 'px'; });
        });
      });
    }, [weeks]);

    // helper: ensure rowRefs entry exists for week
    function ensureRowRefs(weekId, rowIndex){
      if(!rowRefs.current[weekId]) rowRefs.current[weekId] = [];
      if(!rowRefs.current[weekId][rowIndex]) rowRefs.current[weekId][rowIndex] = [];
    }

    // render
    return (
      <div className="p-6 max-w-[1800px] mx-auto">
        <div className="flex justify-between items-center mb-6">
          <h1 className="text-3xl font-bold text-gray-800">Weekly Task Organizer</h1>
          <div className="flex gap-3">
            <button onClick={saveToFile} className="flex items-center gap-2 bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg">
              <i data-lucide="save" className="w-4 h-4"></i> Save
            </button>
            <button onClick={()=>fileInputRef.current?.click()} className="flex items-center gap-2 bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-lg">
              <i data-lucide="upload" className="w-4 h-4"></i> Load
            </button>
            <input ref={fileInputRef} type="file" accept=".json" className="hidden" onChange={loadFromFile} />
            <button onClick={addNewWeek} className="flex items-center gap-2 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg">
              <i data-lucide="plus" className="w-4 h-4"></i> Add Week
            </button>
          </div>
        </div>

        {weeks.map((week, wIdx) => {
          // compute monday date from week.weekNumber & week.year (fallback to current)
          const year = week.year || currentYear;
          const wkNum = Number(week.weekNumber) || currentWeek;
          const monday = getDateOfISOWeek(wkNum, year);
          const dates = [
            monday,
            new Date(monday.getFullYear(), monday.getMonth(), monday.getDate() + 1),
            new Date(monday.getFullYear(), monday.getMonth(), monday.getDate() + 2),
            new Date(monday.getFullYear(), monday.getMonth(), monday.getDate() + 3),
            new Date(monday.getFullYear(), monday.getMonth(), monday.getDate() + 4)
          ];

          return (
            <div key={week.id} className="bg-white rounded-lg shadow pt-2 pb-2 px-6">
              <div className="flex justify-between items-center mb-2">
                <div className="flex items-baseline gap-3">
                  <div className="text-lg font-semibold text-gray-700">
                    {/* editable week number inline in header */}
                    <span contentEditable={false} className="mr-2 text-sm text-gray-600">Week</span>
                    <input
                      value={week.weekNumber}
                      onChange={(e)=> {
                        const v = parseInt(e.target.value) || 0;
                        updateWeekNumber(week.id, v);
                      }}
                      className="w-16 text-lg font-semibold text-gray-700 bg-transparent border-b border-gray-300 focus:outline-none focus:border-gray-500 text-center"
                      title="Click to edit week number"
                    />
                    <span className="ml-2 text-sm text-gray-600">/ Delegated Tasks</span>
                  </div>
                </div>
                <div>
                  {weeks.length > 1 && (
                    <button onClick={()=>deleteWeek(week.id)} className="flex items-center gap-2 bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded text-sm">
                      <i data-lucide="trash-2" className="w-4 h-4"></i> Delete
                    </button>
                  )}
                </div>
              </div>

              <div className="overflow-x-auto">
                <table className="w-full border-collapse">
                  <thead>
                    <tr>
                      {columnLabels.map((label, idx) => (
                        <th key={label} className="border border-gray-300 p-2 bg-gray-700 text-white text-sm">
                          <div className="flex flex-col items-start">
                            <span>{label}</span>
                            {/* for day columns show date under label */}
                            {(label === 'Monday' || label === 'Tuesday' || label === 'Wednesday' || label === 'Thursday' || label === 'Friday') && (
                              <span className="text-xs text-gray-200 mt-1">
                                { formatDayShort(dates[['Monday','Tuesday','Wednesday','Thursday','Friday'].indexOf(label)]) }
                              </span>
                            )}
                          </div>
                        </th>
                      ))}
                    </tr>
                  </thead>
                  <tbody>
                    {week.tasks.map((task, rowIndex) => (
                      <tr key={rowIndex}>
                        {columns.map((col, colIndex) => {
                          const style = getCellStyle(col, rowIndex);
                          ensureRowRefs(week.id, rowIndex);

                          return (
                            <td
                              key={col}
                              draggable
                              onDragStart={(e) => handleDragStart(e, week.id, rowIndex, col)}
                              onDragOver={(e) => e.preventDefault()}
                              onDrop={(e) => handleDrop(e, week.id, rowIndex, col)}
                              ref={el => rowRefs.current[week.id][rowIndex][colIndex] = el}
                              style={{ backgroundColor: style.bg, color: style.text === 'white' ? '#fff' : '#000', verticalAlign: 'top' }}
                              className="p-1"
                            >
                              <div className="flex items-start gap-2">
                                <div className="flex flex-col items-start mr-0" style={{ minWidth: 36 }}>
                                  {/* checkbox close to left */}
                                  <input
                                    type="checkbox"
                                    checked={task[col].completed}
                                    onChange={(e) => updateTask(week.id, rowIndex, col, 'completed', e.target.checked)}
                                    className="w-4 h-4 mt-0.5"
                                  />
                                  {/* small ranking beneath checkbox to the left (compact) */}
                                  <input
                                    type="number"
                                    min="1"
                                    value={task[col].ranking}
                                    onChange={(e) => updateTask(week.id, rowIndex, col, 'ranking', parseInt(e.target.value) || 1)}
                                    className="w-10 text-xs text-center border-0 outline-none mt-1"
                                    style={{ backgroundColor: style.bg, color: style.text === 'white' ? '#fff' : '#000' }}
                                  />
                                </div>

                                <div className="flex-1">
                                  <textarea
                                    value={task[col].text}
                                    onChange={(e) => updateTask(week.id, rowIndex, col, 'text', e.target.value)}
                                    onKeyDown={(e) => handleKeyDown(e, week.id, rowIndex, colIndex)}
                                    ref={el => inputRefs.current[`${week.id}-${rowIndex}-${colIndex}`] = el}
                                    className="w-full text-xs border-0 outline-none resize-none overflow-hidden"
                                    placeholder="Task..."
                                    style={{ minHeight: 20, whiteSpace: 'pre-wrap', backgroundColor: style.bg, color: style.text === 'white' ? '#fff' : '#000' }}
                                    onInput={(e) => { e.target.style.height = 'auto'; e.target.style.height = e.target.scrollHeight + 'px'; }}
                                  />
                                </div>
                              </div>
                            </td>
                          );
                        })}
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          );
        })}
      </div>
    );
  }

  // render
  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<WeeklyTaskOrganizer />);
  </script>
</body>
</html>
